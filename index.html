<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>2026 Drink Tracker</title>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    html, body {
      overflow-x: hidden;
      width: 100%;
      max-width: 100%;
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect } = React;

    // Supabase configuration
    const SUPABASE_URL = 'https://jftfalkxfsasptpoqztd.supabase.co';
    const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImpmdGZhbGt4ZnNhc3B0cG9xenRkIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjY3Njk0OTMsImV4cCI6MjA4MjM0NTQ5M30.zOMezm88s6GMvxVuyT1M0MK_kJKYOsIVg7m614jl_XI';
    
    const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY, {
      auth: {
        persistSession: true,
        autoRefreshToken: true,
        detectSessionInUrl: true,
        storage: window.localStorage,
        storageKey: 'sb-jftfalkxfsasptpoqztd-auth-token'
      }
    });

    // App version - update this when releasing new versions
    const APP_VERSION = '2.0.0';

    // Drinks Database Seed Data
    // This will be migrated to Supabase drinks_database table
    const DRINKS_DATABASE_SEED = [
      // Beers
      { name: 'Guinness', category: 'Beer', calories: 125, cost: null, name_variations: ['guinness', 'guinness stout', 'guinness beer'] },
      { name: 'Budweiser', category: 'Beer', calories: 145, cost: null, name_variations: ['budweiser', 'bud', 'bud light'] },
      { name: 'Heineken', category: 'Beer', calories: 150, cost: null, name_variations: ['heineken', 'heineken beer'] },
      { name: 'Corona', category: 'Beer', calories: 148, cost: null, name_variations: ['corona', 'corona extra', 'corona beer'] },
      { name: 'Stella Artois', category: 'Beer', calories: 154, cost: null, name_variations: ['stella artois', 'stella', 'stella beer'] },
      { name: 'IPA', category: 'Beer', calories: 200, cost: null, name_variations: ['ipa', 'india pale ale', 'pale ale'] },
      { name: 'Lager', category: 'Beer', calories: 150, cost: null, name_variations: ['lager', 'lager beer'] },
      { name: 'Pilsner', category: 'Beer', calories: 150, cost: null, name_variations: ['pilsner', 'pilsner beer', 'pils'] },
      { name: 'Wheat Beer', category: 'Beer', calories: 150, cost: null, name_variations: ['wheat beer', 'hefeweizen', 'wheat'] },
      { name: 'Porter', category: 'Beer', calories: 180, cost: null, name_variations: ['porter', 'porter beer'] },
      { name: 'Stout', category: 'Beer', calories: 200, cost: null, name_variations: ['stout', 'stout beer'] },
      { name: 'Sour Beer', category: 'Beer', calories: 150, cost: null, name_variations: ['sour beer', 'sour', 'sour ale'] },
      { name: 'Modelo', category: 'Beer', calories: 144, cost: null, name_variations: ['modelo', 'modelo especial', 'modelo beer'] },
      { name: 'Dos Equis', category: 'Beer', calories: 145, cost: null, name_variations: ['dos equis', 'xx', 'dos equis beer'] },
      { name: 'Blue Moon', category: 'Beer', calories: 171, cost: null, name_variations: ['blue moon', 'blue moon beer'] },
      { name: 'Sam Adams', category: 'Beer', calories: 175, cost: null, name_variations: ['sam adams', 'samuel adams', 'sam adams beer'] },
      { name: 'Sierra Nevada', category: 'Beer', calories: 175, cost: null, name_variations: ['sierra nevada', 'sierra nevada pale ale'] },
      { name: 'Narragansett', category: 'Beer', calories: 140, cost: null, name_variations: ['narragansett', 'gansett', 'narragansett beer'] },
      
      // Wines
      { name: 'Red Wine', category: 'Wine', calories: 125, cost: null, name_variations: ['red wine', 'red', 'wine red'] },
      { name: 'White Wine', category: 'Wine', calories: 120, cost: null, name_variations: ['white wine', 'white', 'wine white'] },
      { name: 'Rosé', category: 'Wine', calories: 120, cost: null, name_variations: ['rosé', 'rose', 'rose wine', 'rosé wine'] },
      { name: 'Champagne', category: 'Wine', calories: 90, cost: null, name_variations: ['champagne', 'champ'] },
      { name: 'Prosecco', category: 'Wine', calories: 80, cost: null, name_variations: ['prosecco', 'prosecco wine'] },
      { name: 'Pinot Noir', category: 'Wine', calories: 125, cost: null, name_variations: ['pinot noir', 'pinot'] },
      { name: 'Cabernet Sauvignon', category: 'Wine', calories: 125, cost: null, name_variations: ['cabernet sauvignon', 'cabernet', 'cab'] },
      { name: 'Merlot', category: 'Wine', calories: 125, cost: null, name_variations: ['merlot', 'merlot wine'] },
      { name: 'Chardonnay', category: 'Wine', calories: 120, cost: null, name_variations: ['chardonnay', 'chardonnay wine', 'chard'] },
      { name: 'Sauvignon Blanc', category: 'Wine', calories: 120, cost: null, name_variations: ['sauvignon blanc', 'sauv blanc', 'sauvignon'] },
      { name: 'Pinot Grigio', category: 'Wine', calories: 120, cost: null, name_variations: ['pinot grigio', 'pinot gris'] },
      { name: 'Riesling', category: 'Wine', calories: 120, cost: null, name_variations: ['riesling', 'riesling wine'] },
      { name: 'Moscato', category: 'Wine', calories: 127, cost: null, name_variations: ['moscato', 'moscato wine'] },
      { name: 'Malbec', category: 'Wine', calories: 125, cost: null, name_variations: ['malbec', 'malbec wine'] },
      { name: 'Syrah', category: 'Wine', calories: 125, cost: null, name_variations: ['syrah', 'shiraz', 'syrah wine'] },
      { name: 'Zinfandel', category: 'Wine', calories: 125, cost: null, name_variations: ['zinfandel', 'zin', 'zinfandel wine'] },
      { name: 'Sangria', category: 'Wine', calories: 150, cost: null, name_variations: ['sangria', 'sangria wine'] },
      
      // Cocktails
      { name: 'Old Fashioned', category: 'Cocktail', calories: 180, cost: null, name_variations: ['old fashioned', 'old fashioned cocktail'] },
      { name: 'Negroni', category: 'Cocktail', calories: 185, cost: null, name_variations: ['negroni', 'negroni cocktail'] },
      { name: 'Martini', category: 'Cocktail', calories: 160, cost: null, name_variations: ['martini', 'martini cocktail', 'dry martini'] },
      { name: 'Dirty Martini', category: 'Cocktail', calories: 180, cost: null, name_variations: ['dirty martini', 'dirty martini cocktail'] },
      { name: 'Manhattan', category: 'Cocktail', calories: 165, cost: null, name_variations: ['manhattan', 'manhattan cocktail'] },
      { name: 'Moscow Mule', category: 'Cocktail', calories: 150, cost: null, name_variations: ['moscow mule', 'moscow mule cocktail', 'mule'] },
      { name: 'Mojito', category: 'Cocktail', calories: 150, cost: null, name_variations: ['mojito', 'mojito cocktail'] },
      { name: 'Margarita', category: 'Cocktail', calories: 200, cost: null, name_variations: ['margarita', 'margarita cocktail'] },
      { name: 'Cosmopolitan', category: 'Cocktail', calories: 150, cost: null, name_variations: ['cosmopolitan', 'cosmo', 'cosmopolitan cocktail'] },
      { name: 'Daiquiri', category: 'Cocktail', calories: 150, cost: null, name_variations: ['daiquiri', 'daiquiri cocktail'] },
      { name: 'Whiskey Sour', category: 'Cocktail', calories: 160, cost: null, name_variations: ['whiskey sour', 'whisky sour', 'sour'] },
      { name: 'Gin & Tonic', category: 'Cocktail', calories: 150, cost: null, name_variations: ['gin and tonic', 'gin & tonic', 'g&t', 'g and t'] },
      { name: 'Rum & Coke', category: 'Cocktail', calories: 180, cost: null, name_variations: ['rum and coke', 'rum & coke', 'cuba libre'] },
      { name: 'Vodka Soda', category: 'Cocktail', calories: 100, cost: null, name_variations: ['vodka soda', 'vodka and soda'] },
      { name: 'Vodka Cranberry', category: 'Cocktail', calories: 150, cost: null, name_variations: ['vodka cranberry', 'vodka and cranberry', 'cape cod'] },
      { name: 'Screwdriver', category: 'Cocktail', calories: 180, cost: null, name_variations: ['screwdriver', 'vodka orange'] },
      { name: 'Bloody Mary', category: 'Cocktail', calories: 120, cost: null, name_variations: ['bloody mary', 'bloody mary cocktail'] },
      { name: 'Mimosa', category: 'Cocktail', calories: 150, cost: null, name_variations: ['mimosa', 'mimosa cocktail'] },
      { name: 'Bellini', category: 'Cocktail', calories: 120, cost: null, name_variations: ['bellini', 'bellini cocktail'] },
      { name: 'Espresso Martini', category: 'Cocktail', calories: 200, cost: null, name_variations: ['espresso martini', 'espresso martini cocktail'] },
      { name: 'French 75', category: 'Cocktail', calories: 150, cost: null, name_variations: ['french 75', 'french 75 cocktail'] },
      { name: 'Aperol Spritz', category: 'Cocktail', calories: 150, cost: null, name_variations: ['aperol spritz', 'spritz', 'aperol spritz cocktail'] },
      { name: 'Paloma', category: 'Cocktail', calories: 200, cost: null, name_variations: ['paloma', 'paloma cocktail'] },
      { name: 'Tom Collins', category: 'Cocktail', calories: 150, cost: null, name_variations: ['tom collins', 'collins', 'tom collins cocktail'] },
      { name: 'Sidecar', category: 'Cocktail', calories: 180, cost: null, name_variations: ['sidecar', 'sidecar cocktail'] },
      { name: 'Boulevardier', category: 'Cocktail', calories: 185, cost: null, name_variations: ['boulevardier', 'boulevardier cocktail'] },
      { name: 'Sazerac', category: 'Cocktail', calories: 180, cost: null, name_variations: ['sazerac', 'sazerac cocktail'] },
      { name: 'Last Word', category: 'Cocktail', calories: 150, cost: null, name_variations: ['last word', 'last word cocktail'] },
      { name: 'Paper Plane', category: 'Cocktail', calories: 150, cost: null, name_variations: ['paper plane', 'paper plane cocktail'] },
      { name: 'Bourbon', category: 'Cocktail', calories: 100, cost: null, name_variations: ['bourbon', 'bourbon whiskey', 'bourbon neat'] },
      { name: 'Scotch', category: 'Cocktail', calories: 100, cost: null, name_variations: ['scotch', 'scotch whisky', 'scotch neat'] },
      { name: 'Whiskey', category: 'Cocktail', calories: 100, cost: null, name_variations: ['whiskey', 'whisky', 'whiskey neat'] },
      { name: 'Tequila Shot', category: 'Cocktail', calories: 100, cost: null, name_variations: ['tequila shot', 'tequila', 'shot of tequila'] },
      { name: 'Vodka Shot', category: 'Cocktail', calories: 100, cost: null, name_variations: ['vodka shot', 'vodka', 'shot of vodka'] },
      { name: 'Rum Shot', category: 'Cocktail', calories: 100, cost: null, name_variations: ['rum shot', 'rum', 'shot of rum'] },
      { name: 'Gin Shot', category: 'Cocktail', calories: 100, cost: null, name_variations: ['gin shot', 'gin', 'shot of gin'] },
    ];

    function DrinkTracker() {
      const [user, setUser] = useState(null);
      const [session, setSession] = useState(null);
      const [authLoading, setAuthLoading] = useState(true);
      const [drinks, setDrinks] = useState([]);
      const [loading, setLoading] = useState(true);
      const [showOtherForm, setShowOtherForm] = useState(false);
      const [customDrink, setCustomDrink] = useState('');
      const [quickLogDrinks, setQuickLogDrinks] = useState([
        { name: 'Martini', category: 'Cocktail' },
        { name: 'Gin & Tonic', category: 'Cocktail' },
        { name: 'Guinness', category: 'Beer' },
        { name: 'Narragansett', category: 'Beer' },
        { name: 'White Wine', category: 'Wine' },
        { name: 'Red Wine', category: 'Wine' }
      ]);
      const [dismissedSuggestions, setDismissedSuggestions] = useState([]);
      const [editMode, setEditMode] = useState(false);
      const [editingDrink, setEditingDrink] = useState(null);
      const [editName, setEditName] = useState('');
      const [editCategory, setEditCategory] = useState('');
      
      // Pagination state
      const [currentPage, setCurrentPage] = useState(1);
      const itemsPerPage = 10;
      
      // Auth form state
      const [showLogin, setShowLogin] = useState(false);
      const [showSignup, setShowSignup] = useState(false);
      const [email, setEmail] = useState('');
      const [password, setPassword] = useState('');
      const [authError, setAuthError] = useState('');
      
      // Caching and offline state
      const [isOnline, setIsOnline] = useState(navigator.onLine);
      const [isSyncing, setIsSyncing] = useState(false);
      const [cacheTimestamp, setCacheTimestamp] = useState(null);
      const CACHE_VALIDITY_MS = 5 * 60 * 1000; // 5 minutes
      
      // Bulk delete state
      const [showBulkDelete, setShowBulkDelete] = useState(false);
      const [deleteStartDate, setDeleteStartDate] = useState('');
      const [deleteEndDate, setDeleteEndDate] = useState('');
      const [deleting, setDeleting] = useState(false);
      
      // Dashboard state
      const [dashboardPeriod, setDashboardPeriod] = useState('all'); // 'week' | 'month' | 'year' | 'all'
      const [dashboardCategoryFilter, setDashboardCategoryFilter] = useState('all'); // 'all' | 'Beer' | 'Wine' | 'Cocktail'
      const [dashboardSearchQuery, setDashboardSearchQuery] = useState('');
      const [dashboardPresetPeriod, setDashboardPresetPeriod] = useState('all'); // 'thisWeek' | 'thisMonth' | 'last30Days' | 'thisYear' | 'all'

      // Freeform parsing state
      const [freeformText, setFreeformText] = useState('');
      const [parsedDrinks, setParsedDrinks] = useState([]);
      const [drinksDatabase, setDrinksDatabase] = useState(DRINKS_DATABASE_SEED);
      
      // Drink detail/edit state
      const [selectedDrink, setSelectedDrink] = useState(null);
      const [editingDrinkDetail, setEditingDrinkDetail] = useState(null);
      const [showDrinkDetail, setShowDrinkDetail] = useState(false);
      
      // Date/time selection for freeform logging
      const [freeformDateTime, setFreeformDateTime] = useState(null); // null = use "now"
      const [showFreeformDateTime, setShowFreeformDateTime] = useState(false);
      
      // Quick Log date/time editing
      const [quickLogDateTime, setQuickLogDateTime] = useState(null);
      const [showQuickLogDateTime, setShowQuickLogDateTime] = useState(false);
      const [pendingQuickLogDrink, setPendingQuickLogDrink] = useState(null);

      // Parsing Functions
      const numberWords = {
        'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': 5,
        'six': 6, 'seven': 7, 'eight': 8, 'nine': 9, 'ten': 10,
        'eleven': 11, 'twelve': 12, 'thirteen': 13, 'fourteen': 14, 'fifteen': 15
      };

      const normalizeText = (text) => {
        return text.toLowerCase().trim().replace(/[^\w\s]/g, '');
      };

      const extractQuantity = (text) => {
        // Try to find numbers first
        const numberMatch = text.match(/(\d+)\s*(x|×)?/i);
        if (numberMatch) {
          return parseInt(numberMatch[1]);
        }
        
        // Try number words
        for (const [word, num] of Object.entries(numberWords)) {
          if (text.toLowerCase().includes(word)) {
            return num;
          }
        }
        
        // Default to 1 if no quantity found
        return 1;
      };

      const fuzzyMatchDrink = (input, database) => {
        const normalizedInput = normalizeText(input);
        
        // Exact match first
        for (const drink of database) {
          if (normalizeText(drink.name) === normalizedInput) {
            return drink;
          }
          // Check variations
          if (drink.name_variations) {
            for (const variation of drink.name_variations) {
              if (normalizeText(variation) === normalizedInput) {
                return drink;
              }
            }
          }
        }
        
        // Fuzzy match - check if input contains drink name or vice versa
        for (const drink of database) {
          const normalizedDrink = normalizeText(drink.name);
          if (normalizedInput.includes(normalizedDrink) || normalizedDrink.includes(normalizedInput)) {
            return drink;
          }
          // Check variations
          if (drink.name_variations) {
            for (const variation of drink.name_variations) {
              const normalizedVariation = normalizeText(variation);
              if (normalizedInput.includes(normalizedVariation) || normalizedVariation.includes(normalizedInput)) {
                return drink;
              }
            }
          }
        }
        
        // Category inference for generic terms
        if (normalizedInput.includes('beer') || normalizedInput.includes('beers')) {
          return { name: 'Beer', category: 'Beer', calories: 150, cost: null, name_variations: [] };
        }
        if (normalizedInput.includes('wine') || normalizedInput.includes('wines')) {
          return { name: 'Wine', category: 'Wine', calories: 125, cost: null, name_variations: [] };
        }
        if (normalizedInput.includes('cocktail') || normalizedInput.includes('cocktails')) {
          return { name: 'Cocktail', category: 'Cocktail', calories: 150, cost: null, name_variations: [] };
        }
        
        return null;
      };

      const parseNaturalLanguageDateTime = (text) => {
        const normalized = text.toLowerCase().trim();
        const now = new Date();
        let dateTime = null;
        
        // Common patterns
        if (normalized.includes('last night') || normalized.includes('yesterday night')) {
          dateTime = new Date(now);
          dateTime.setDate(now.getDate() - 1);
          dateTime.setHours(23, 0, 0, 0); // 11 PM
        } else if (normalized.includes('yesterday')) {
          dateTime = new Date(now);
          dateTime.setDate(now.getDate() - 1);
          if (now.getHours() < 8) {
            dateTime.setHours(20, 0, 0, 0); // 8 PM if early morning
          } else {
            dateTime.setHours(now.getHours(), now.getMinutes(), 0, 0);
          }
        } else if (normalized.includes('today')) {
          dateTime = new Date(now);
        } else if (normalized.includes('this morning')) {
          dateTime = new Date(now);
          dateTime.setHours(9, 0, 0, 0);
        } else if (normalized.includes('this afternoon')) {
          dateTime = new Date(now);
          dateTime.setHours(15, 0, 0, 0);
        } else if (normalized.includes('this evening') || normalized.includes('tonight')) {
          dateTime = new Date(now);
          dateTime.setHours(20, 0, 0, 0);
        } else {
          // Try to parse "X days ago"
          const daysAgoMatch = normalized.match(/(\d+)\s*days?\s*ago/i);
          if (daysAgoMatch) {
            const days = parseInt(daysAgoMatch[1]);
            dateTime = new Date(now);
            dateTime.setDate(now.getDate() - days);
            dateTime.setHours(20, 0, 0, 0); // Default to 8 PM
          } else {
            // Try day names (last friday, last saturday, etc.)
            const dayNames = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
            for (let i = 0; i < dayNames.length; i++) {
              if (normalized.includes(`last ${dayNames[i]}`) || normalized.includes(`on ${dayNames[i]}`)) {
                dateTime = new Date(now);
                const currentDay = now.getDay();
                const targetDay = i;
                let daysBack = currentDay - targetDay;
                if (daysBack <= 0) daysBack += 7; // Go back to last week
                dateTime.setDate(now.getDate() - daysBack);
                dateTime.setHours(20, 0, 0, 0);
                break;
              }
            }
          }
        }
        
        return dateTime ? dateTime.toISOString() : null;
      };

      const extractDateTimeFromText = (text) => {
        // Look for date/time patterns at the end of the text
        const dateTimePatterns = [
          /(last\s+night|yesterday\s+night)/i,
          /(yesterday)/i,
          /(today|this\s+morning|this\s+afternoon|this\s+evening|tonight)/i,
          /(\d+\s+days?\s+ago)/i,
          /(last\s+(sunday|monday|tuesday|wednesday|thursday|friday|saturday))/i,
          /(on\s+(sunday|monday|tuesday|wednesday|thursday|friday|saturday))/i
        ];
        
        for (const pattern of dateTimePatterns) {
          const match = text.match(pattern);
          if (match) {
            return parseNaturalLanguageDateTime(match[0]);
          }
        }
        
        return null;
      };

      const parseFreeformText = (text) => {
        if (!text || !text.trim()) return [];
        
        // Extract date/time from the entire text (applies to all drinks)
        const extractedDateTime = extractDateTimeFromText(text);
        
        const results = [];
        // Split by common delimiters: comma, "and", "&"
        const parts = text.split(/[,&]|and/i).map(p => p.trim()).filter(p => p);
        
        for (const part of parts) {
          const quantity = extractQuantity(part);
          // Remove quantity from text to get drink name
          let drinkText = part.replace(/\d+\s*(x|×)?/i, '').trim();
          drinkText = drinkText.replace(/\b(one|two|three|four|five|six|seven|eight|nine|ten|eleven|twelve|thirteen|fourteen|fifteen)\b/gi, '').trim();
          
          // Remove date/time expressions from drink text
          drinkText = drinkText.replace(/\b(last\s+night|yesterday\s+night|yesterday|today|this\s+morning|this\s+afternoon|this\s+evening|tonight|\d+\s+days?\s+ago|last\s+(sunday|monday|tuesday|wednesday|thursday|friday|saturday)|on\s+(sunday|monday|tuesday|wednesday|thursday|friday|saturday))\b/gi, '').trim();
          
          if (!drinkText) continue;
          
          const matchedDrink = fuzzyMatchDrink(drinkText, drinksDatabase);
          
          if (matchedDrink) {
            for (let i = 0; i < quantity; i++) {
              results.push({
                name: matchedDrink.name,
                category: matchedDrink.category,
                calories: matchedDrink.calories,
                cost: matchedDrink.cost,
                originalText: part.trim(),
                matched: true,
                timestamp: extractedDateTime || null // Use extracted date/time or null (will default to "now")
              });
            }
          } else {
            // Unrecognized drink - still add it
            for (let i = 0; i < quantity; i++) {
              results.push({
                name: drinkText,
                category: 'Cocktail', // Default category
                calories: null,
                cost: null,
                originalText: part.trim(),
                matched: false,
                timestamp: extractedDateTime || null
              });
            }
          }
        }
        
        return results;
      };

      // Date/Time Preset Functions
      const applyDateTimePreset = (preset) => {
        const now = new Date();
        let dateTime;
        
        switch (preset) {
          case 'now':
            dateTime = new Date();
            break;
          case 'yesterday':
            dateTime = new Date(now);
            dateTime.setDate(now.getDate() - 1);
            // If current time is early morning (before 8 AM), default to 8 PM yesterday
            if (now.getHours() < 8) {
              dateTime.setHours(20, 0, 0, 0);
            } else {
              dateTime.setHours(now.getHours(), now.getMinutes(), now.getSeconds(), now.getMilliseconds());
            }
            break;
          case 'lastNight':
            dateTime = new Date(now);
            dateTime.setDate(now.getDate() - 1);
            dateTime.setHours(23, 0, 0, 0); // 11 PM previous day
            break;
          case 'custom':
            // Return null to indicate custom picker should be shown
            return null;
          default:
            dateTime = new Date();
        }
        
        return dateTime.toISOString();
      };

      const formatDateTimeForDisplay = (timestamp) => {
        const date = new Date(timestamp);
        return date.toLocaleDateString('en-US', { 
          month: 'short', 
          day: 'numeric', 
          year: 'numeric' 
        }) + ' at ' + date.toLocaleTimeString('en-US', { 
          hour: 'numeric', 
          minute: '2-digit',
          hour12: true 
        });
      };

      const parseDateTimeInput = (dateStr, timeStr) => {
        if (!dateStr) return null;
        const date = new Date(dateStr);
        if (timeStr) {
          const [hours, minutes] = timeStr.split(':');
          date.setHours(parseInt(hours), parseInt(minutes), 0, 0);
        }
        return date.toISOString();
      };

      const openDrinkDetail = (drink) => {
        setSelectedDrink(drink);
        setEditingDrinkDetail({
          ...drink,
          editDate: new Date(drink.timestamp).toISOString().split('T')[0],
          editTime: new Date(drink.timestamp).toTimeString().slice(0, 5),
          editDateTimePreset: 'custom'
        });
        setShowDrinkDetail(true);
      };

      // Check for existing session on mount
      // Note: We rely on onAuthStateChange INITIAL_SESSION event, but also call checkSession as backup
      useEffect(() => {
        // Wait a moment for Supabase to initialize, then check session
        const timer = setTimeout(() => {
          checkSession();
        }, 500);
        
        return () => clearTimeout(timer);
      }, []);

      // Offline/online detection
      useEffect(() => {
        const handleOnline = () => setIsOnline(true);
        const handleOffline = () => setIsOnline(false);
        
        window.addEventListener('online', handleOnline);
        window.addEventListener('offline', handleOffline);
        
        return () => {
          window.removeEventListener('online', handleOnline);
          window.removeEventListener('offline', handleOffline);
        };
      }, []);

      // Sync when coming back online
      useEffect(() => {
        if (isOnline && user) {
          syncWhenOnline();
        }
      }, [isOnline, user?.id]);

      // Load data when user is available
      useEffect(() => {
        if (user) {
          loadData();
        }
      }, [user]);

      // Parse freeform text with debounce
      useEffect(() => {
        if (!showOtherForm || !freeformText.trim()) {
          setParsedDrinks([]);
          return;
        }
        
        const timer = setTimeout(() => {
          const parsed = parseFreeformText(freeformText);
          setParsedDrinks(parsed);
        }, 300); // 300ms debounce
        
        return () => clearTimeout(timer);
      }, [freeformText, showOtherForm, drinksDatabase]);


      const checkSession = async () => {
        try {
          // Get the session - Supabase handles persistence automatically
          const { data: { session }, error } = await supabase.auth.getSession();
          
          if (error) {
            console.error('Error getting session:', error);
            setSession(null);
            setUser(null);
            setAuthLoading(false);
            return;
          }
          
          // If we have a session, restore it
          if (session && session.user) {
            setSession(session);
            setUser(session.user);
            loadCachedDrinks(session.user.id);
          } else {
            // Don't clear state if user already exists (might have been set by INITIAL_SESSION handler)
            if (!user) {
              setSession(null);
              setUser(null);
            }
          }
        } catch (error) {
          console.error('Error checking session:', error);
          if (!user) {
            setSession(null);
            setUser(null);
          }
        } finally {
          setAuthLoading(false);
        }
      };

      const handleSignUp = async (e) => {
        e.preventDefault();
        setAuthError('');
        
        try {
          const { data, error } = await supabase.auth.signUp({
            email: email,
            password: password,
            options: {
              emailRedirectTo: `${window.location.origin}${window.location.pathname}`
            }
          });

          if (error) throw error;

          if (data.user) {
            // If session exists, user is immediately signed in (email confirmation disabled)
            // If no session, user needs to confirm email first
            if (data.session) {
              setUser(data.user);
              setSession(data.session);
              setShowSignup(false);
              setEmail('');
              setPassword('');
            } else {
              // Email confirmation required
              setShowSignup(false);
              setEmail('');
              setPassword('');
              alert('Account created! Please check your email to confirm your account before signing in.');
            }
          }
        } catch (error) {
          setAuthError(error.message);
          console.error('Error signing up:', error);
        }
      };

      const handleSignIn = async (e) => {
        e.preventDefault();
        setAuthError('');
        
        try {
          const { data, error } = await supabase.auth.signInWithPassword({
            email: email,
            password: password,
          });

          if (error) throw error;

          if (data.user && data.session) {
            setUser(data.user);
            setSession(data.session);
            setShowLogin(false);
            setEmail('');
            setPassword('');
          } else {
            setAuthError('Sign in succeeded but session was not created. Please try again.');
          }
        } catch (error) {
          setAuthError(error.message);
          console.error('Error signing in:', error);
        }
      };

      const handleSignOut = async () => {
        try {
          // Clear cached data before signing out
          if (user) {
            const userId = user.id;
            localStorage.removeItem(`drinks-cache-2026-${userId}`);
            localStorage.removeItem(`drinks-cache-timestamp-2026-${userId}`);
            localStorage.removeItem(`quicklog-2026-${userId}`);
            localStorage.removeItem(`dismissed-suggestions-2026-${userId}`);
          }
          
          const { error } = await supabase.auth.signOut();
          if (error) throw error;
          
          setUser(null);
          setSession(null);
          setDrinks([]);
          setCacheTimestamp(null);
          setQuickLogDrinks([
            { name: 'Martini', category: 'Cocktail' },
            { name: 'Gin & Tonic', category: 'Cocktail' },
            { name: 'Guinness', category: 'Beer' },
            { name: 'Narragansett', category: 'Beer' },
            { name: 'White Wine', category: 'Wine' },
            { name: 'Red Wine', category: 'Wine' }
          ]);
          setDismissedSuggestions([]);
        } catch (error) {
          console.error('Error signing out:', error);
        }
      };

      // Listen for auth changes (including email confirmation)
      useEffect(() => {
        const { data: { subscription } } = supabase.auth.onAuthStateChange((event, session) => {
          // Handle different auth events
          if (event === 'SIGNED_IN' && session) {
            setSession(session);
            setUser(session.user);
          } else if (event === 'TOKEN_REFRESHED' && session) {
            setSession(session);
            setUser(session.user);
          } else if (event === 'SIGNED_OUT') {
            // Clear all cached data on sign out
            if (user) {
              const userId = user.id;
              localStorage.removeItem(`drinks-cache-2026-${userId}`);
              localStorage.removeItem(`drinks-cache-timestamp-2026-${userId}`);
            }
            setSession(null);
            setUser(null);
            setDrinks([]);
            setCacheTimestamp(null);
          } else if (event === 'INITIAL_SESSION') {
            // This fires when Supabase restores a session from storage
            if (session && session.user) {
              setSession(session);
              setUser(session.user);
              setAuthLoading(false);
              loadCachedDrinks(session.user.id);
            } else {
              // INITIAL_SESSION fired but session is null - try to restore from localStorage
              const supabaseKey = 'sb-jftfalkxfsasptpoqztd-auth-token';
              const stored = localStorage.getItem(supabaseKey);
              
              if (stored) {
                try {
                  const parsed = JSON.parse(stored);
                  const storedSession = parsed?.currentSession;
                  
                  if (storedSession && storedSession.user) {
                    // Check if expired
                    const expiresAt = storedSession.expires_at;
                    if (expiresAt) {
                      const now = Math.floor(Date.now() / 1000);
                      if (expiresAt < now) {
                        // Try to refresh expired session
                        supabase.auth.refreshSession().then(({ data: { session: refreshed }, error }) => {
                          if (error || !refreshed) {
                            setSession(null);
                            setUser(null);
                            setAuthLoading(false);
                          } else {
                            setSession(refreshed);
                            setUser(refreshed.user);
                            setAuthLoading(false);
                            loadCachedDrinks(refreshed.user.id);
                          }
                        });
                        return;
                      }
                    }
                    
                    // Restore session from localStorage
                    setSession(storedSession);
                    setUser(storedSession.user);
                    setAuthLoading(false);
                    loadCachedDrinks(storedSession.user.id);
                  } else {
                    setSession(null);
                    setUser(null);
                    setAuthLoading(false);
                  }
                } catch (e) {
                  console.error('Error parsing localStorage:', e);
                  setSession(null);
                  setUser(null);
                  setAuthLoading(false);
                }
              } else {
                setSession(null);
                setUser(null);
                setAuthLoading(false);
              }
            }
          } else {
            // For other events, update state if we have a session
            if (session) {
              setSession(session);
              setUser(session.user);
            }
          }
        });

        return () => subscription.unsubscribe();
      }, []);

      const cacheDrinksData = (drinksData, userId) => {
        if (!userId) return;
        try {
          const cacheKey = `drinks-cache-2026-${userId}`;
          const timestampKey = `drinks-cache-timestamp-2026-${userId}`;
          localStorage.setItem(cacheKey, JSON.stringify(drinksData));
          localStorage.setItem(timestampKey, Date.now().toString());
          setCacheTimestamp(Date.now());
        } catch (error) {
          console.error('Error caching drinks data:', error);
        }
      };

      const loadCachedDrinks = (userId) => {
        if (!userId) return null;
        try {
          const cacheKey = `drinks-cache-2026-${userId}`;
          const timestampKey = `drinks-cache-timestamp-2026-${userId}`;
          const cached = localStorage.getItem(cacheKey);
          const timestamp = localStorage.getItem(timestampKey);
          
          if (cached && timestamp) {
            const cacheAge = Date.now() - parseInt(timestamp);
            const cachedData = JSON.parse(cached);
            
            // Return cached data if it's still valid
            if (cacheAge < CACHE_VALIDITY_MS) {
              setDrinks(cachedData);
              setCacheTimestamp(parseInt(timestamp));
              return cachedData;
            }
          }
        } catch (error) {
          console.error('Error loading cached drinks:', error);
        }
        return null;
      };

      const checkOnlineStatus = () => {
        return navigator.onLine;
      };

      const syncWhenOnline = async () => {
        if (!isOnline || isSyncing) return;
        
        setIsSyncing(true);
        try {
          // Get current session to ensure we're authenticated
          const { data: { session: currentSession } } = await supabase.auth.getSession();
          if (!currentSession || !currentSession.user) {
            setIsSyncing(false);
            return;
          }
          
          // Reload fresh data from server
          const { data: drinksData, error } = await supabase
            .from('drinks')
            .select('*')
            .eq('user_id', currentSession.user.id)
            .order('timestamp', { ascending: false });

          if (error) throw error;
          
          if (drinksData) {
            setDrinks(drinksData);
            cacheDrinksData(drinksData, currentSession.user.id);
          }
        } catch (error) {
          console.error('Error syncing data:', error);
        } finally {
          setIsSyncing(false);
        }
      };

      const loadData = async () => {
        if (!user) {
          setLoading(false);
          return;
        }

        // First, try to load cached data for instant display
        const cachedData = loadCachedDrinks(user.id);
        if (cachedData && cachedData.length > 0) {
          setLoading(false); // Show cached data immediately
        }

        try {
          // Then fetch fresh data from Supabase
          const { data: drinksData, error } = await supabase
            .from('drinks')
            .select('*')
            .eq('user_id', user.id)
            .order('timestamp', { ascending: false });

          if (error) {
            // If offline or network error, use cached data
            if (!isOnline || error.message.includes('fetch')) {
              console.warn('Network error, using cached data');
              if (!cachedData || cachedData.length === 0) {
                setLoading(false);
              }
              return;
            }
            throw error;
          }
          
          if (drinksData) {
            setDrinks(drinksData);
            cacheDrinksData(drinksData, user.id);
          }

          // Load quick log and dismissed from localStorage (user-specific)
          const userKey = `quicklog-2026-${user.id}`;
          const storedQuickLog = localStorage.getItem(userKey);
          if (storedQuickLog) {
            setQuickLogDrinks(JSON.parse(storedQuickLog));
          }

          const dismissedKey = `dismissed-suggestions-2026-${user.id}`;
          const storedDismissed = localStorage.getItem(dismissedKey);
          if (storedDismissed) {
            setDismissedSuggestions(JSON.parse(storedDismissed));
          }
        } catch (error) {
          console.error('Error loading data:', error);
          // Show error to user if it's a critical issue
          if (error.message && (error.message.includes('column') || error.message.includes('permission'))) {
            alert(`Database error: ${error.message}\n\nPlease check your Supabase setup. See SUPABASE_SETUP.md for instructions.`);
          }
        } finally {
          setLoading(false);
        }
      };

      const saveQuickLog = (newQuickLog) => {
        if (!user) return;
        const userKey = `quicklog-2026-${user.id}`;
        localStorage.setItem(userKey, JSON.stringify(newQuickLog));
      };

      const saveDismissed = (newDismissed) => {
        if (!user) return;
        const dismissedKey = `dismissed-suggestions-2026-${user.id}`;
        localStorage.setItem(dismissedKey, JSON.stringify(newDismissed));
      };

      const normalizeDrinkName = (name) => {
        return name.toLowerCase().trim();
      };

      const quickAddDrinkWithTimestamp = async (name, category, timestamp) => {
        if (!user) return;
        
        try {
          // Get current session to ensure we use the authenticated user ID
          const { data: { session: currentSession } } = await supabase.auth.getSession();
          
          if (!currentSession || !currentSession.access_token) {
            throw new Error('No valid session found. Please sign in again.');
          }
          
          // Try to match drink in database to get calories/cost
          const matchedDrink = fuzzyMatchDrink(name, drinksDatabase);
          
          const newDrink = {
            name: name,
            category: category,
            calories: matchedDrink ? matchedDrink.calories : null,
            cost: matchedDrink ? matchedDrink.cost : null,
            timestamp: timestamp || new Date().toISOString(),
            user_id: currentSession.user.id
          };

          const { data, error } = await supabase
            .from('drinks')
            .insert([newDrink])
            .select();

          if (error) throw error;

          if (data) {
            const updatedDrinks = [data[0], ...drinks];
            setDrinks(updatedDrinks);
            // Update cache
            cacheDrinksData(updatedDrinks, currentSession.user.id);
          }
        } catch (error) {
          console.error('Error adding drink:', error);
          const errorMessage = error.message || 'Unknown error occurred';
          
          // If offline, queue the action
          if (!isOnline || error.message.includes('fetch')) {
            alert('You are offline. The drink will be saved when you reconnect.');
            // Could implement offline queue here
            return;
          }
          
          alert(`Failed to add drink: ${errorMessage}\n\nCheck the browser console (F12) for more details.\n\nIf you see "column" or "permission" errors, you may need to set up your Supabase database. See SUPABASE_SETUP.md for instructions.`);
        }
      };

      const quickAddDrink = async (name, category) => {
        // Default to current time
        await quickAddDrinkWithTimestamp(name, category, new Date().toISOString());
      };

      const addCustomDrink = async (category) => {
        if (!customDrink.trim() || !user) return;
        
        try {
          // Get current session to ensure we use the authenticated user ID
          const { data: { session: currentSession } } = await supabase.auth.getSession();
          
          if (!currentSession || !currentSession.access_token) {
            throw new Error('No valid session found. Please sign in again.');
          }
          
          const newDrink = {
            name: customDrink.trim(),
            category: category,
            timestamp: new Date().toISOString(),
            user_id: currentSession.user.id
          };

          const { data, error } = await supabase
            .from('drinks')
            .insert([newDrink])
            .select();

          if (error) throw error;

          if (data) {
            const updatedDrinks = [data[0], ...drinks];
            setDrinks(updatedDrinks);
            // Update cache
            cacheDrinksData(updatedDrinks, currentSession.user.id);
          }
          
          setCustomDrink('');
          setShowOtherForm(false);
        } catch (error) {
          console.error('Error adding drink:', error);
          const errorMessage = error.message || 'Unknown error occurred';
          
          // If offline, queue the action
          if (!isOnline || error.message.includes('fetch')) {
            alert('You are offline. The drink will be saved when you reconnect.');
            return;
          }
          
          alert(`Failed to add drink: ${errorMessage}\n\nCheck the browser console (F12) for more details.\n\nIf you see "column" or "permission" errors, you may need to set up your Supabase database. See SUPABASE_SETUP.md for instructions.`);
        }
      };

      const batchLogDrinks = async (drinksToLog) => {
        if (!drinksToLog || drinksToLog.length === 0 || !user) return;
        
        try {
          // Get current session to ensure we use the authenticated user ID
          const { data: { session: currentSession } } = await supabase.auth.getSession();
          
          if (!currentSession || !currentSession.access_token) {
            throw new Error('No valid session found. Please sign in again.');
          }
          
          // Determine timestamp - priority: drink.timestamp (from NLP) > freeformDateTime > "now"
          const drinksToInsert = drinksToLog.map(drink => {
            let timestamp;
            
            // First check if drink has timestamp from NLP parsing
            if (drink.timestamp) {
              timestamp = drink.timestamp;
            } else if (freeformDateTime) {
              // Use freeform date/time selection
              if (freeformDateTime.preset === 'custom' && freeformDateTime.date) {
                timestamp = parseDateTimeInput(freeformDateTime.date, freeformDateTime.time) || new Date().toISOString();
              } else if (freeformDateTime.preset !== 'custom') {
                const presetDateTime = applyDateTimePreset(freeformDateTime.preset);
                timestamp = presetDateTime || new Date().toISOString();
              } else {
                timestamp = new Date().toISOString();
              }
            } else {
              // Default to "now"
              timestamp = new Date().toISOString();
            }
            
            return {
              name: drink.name.trim(),
              category: drink.category,
              calories: drink.calories,
              cost: drink.cost,
              timestamp: timestamp,
              user_id: currentSession.user.id
            };
          });

          const { data, error } = await supabase
            .from('drinks')
            .insert(drinksToInsert)
            .select();

          if (error) throw error;

          if (data) {
            const updatedDrinks = [...data, ...drinks];
            setDrinks(updatedDrinks);
            // Update cache
            cacheDrinksData(updatedDrinks, currentSession.user.id);
          }
          
          setFreeformText('');
          setParsedDrinks([]);
          setFreeformDateTime(null);
          setShowFreeformDateTime(false);
          setShowOtherForm(false);
        } catch (error) {
          console.error('Error adding drinks:', error);
          const errorMessage = error.message || 'Unknown error occurred';
          
          // If offline, queue the action
          if (!isOnline || error.message.includes('fetch')) {
            alert('You are offline. The drinks will be saved when you reconnect.');
            return;
          }
          
          alert(`Failed to add drinks: ${errorMessage}\n\nCheck the browser console (F12) for more details.`);
        }
      };

      const updateParsedDrink = (index, field, value) => {
        const updated = [...parsedDrinks];
        updated[index] = { ...updated[index], [field]: value };
        setParsedDrinks(updated);
      };

      const removeParsedDrink = (index) => {
        const updated = parsedDrinks.filter((_, i) => i !== index);
        setParsedDrinks(updated);
      };

      const updateDrink = async (drinkId, updates) => {
        if (!user) return;
        
        try {
          // Get current session to ensure we use the authenticated user ID
          const { data: { session: currentSession } } = await supabase.auth.getSession();
          
          if (!currentSession || !currentSession.access_token) {
            throw new Error('No valid session found. Please sign in again.');
          }

          // Prepare update object
          const updateData = {};
          if (updates.timestamp) updateData.timestamp = updates.timestamp;
          if (updates.calories !== undefined) updateData.calories = updates.calories;
          if (updates.cost !== undefined) updateData.cost = updates.cost;
          if (updates.serving_size !== undefined) updateData.serving_size = updates.serving_size;

          const { data, error } = await supabase
            .from('drinks')
            .update(updateData)
            .eq('id', drinkId)
            .eq('user_id', currentSession.user.id)
            .select();

          if (error) throw error;

          if (data && data.length > 0) {
            const updatedDrinks = drinks.map(d => d.id === drinkId ? data[0] : d);
            setDrinks(updatedDrinks);
            // Update cache
            cacheDrinksData(updatedDrinks, currentSession.user.id);
            return data[0];
          }
        } catch (error) {
          console.error('Error updating drink:', error);
          const errorMessage = error.message || 'Unknown error occurred';
          
          // If offline, show message
          if (!isOnline || error.message.includes('fetch')) {
            alert('You are offline. The update will be synced when you reconnect.');
            return;
          }
          
          alert(`Failed to update drink: ${errorMessage}`);
          throw error;
        }
      };

      const deleteDrink = async (id) => {
        if (!user) return;
        
        try {
          const { error } = await supabase
            .from('drinks')
            .delete()
            .eq('id', id)
            .eq('user_id', user.id); // Ensure user can only delete their own drinks

          if (error) throw error;

          const updatedDrinks = drinks.filter(d => d.id !== id);
          setDrinks(updatedDrinks);
          // Update cache
          cacheDrinksData(updatedDrinks, user.id);
        } catch (error) {
          console.error('Error deleting drink:', error);
          
          // If offline, show message
          if (!isOnline || error.message.includes('fetch')) {
            alert('You are offline. The deletion will be synced when you reconnect.');
            return;
          }
          
          alert('Failed to delete drink. Please try again.');
        }
      };

      const getDrinksInDateRange = (startDate, endDate) => {
        if (!startDate || !endDate) return { count: 0, drinks: [] };
        
        const start = new Date(startDate);
        const end = new Date(endDate);
        // Set end date to end of day
        end.setHours(23, 59, 59, 999);
        
        const filtered = drinks.filter(drink => {
          const drinkDate = new Date(drink.timestamp);
          return drinkDate >= start && drinkDate <= end;
        });
        
        return {
          count: filtered.length,
          drinks: filtered
        };
      };

      const deleteDrinksByDateRange = async (startDate, endDate) => {
        if (!user) return;
        
        // Validate date range
        if (!startDate || !endDate) {
          alert('Please select both start and end dates.');
          return;
        }
        
        const start = new Date(startDate);
        const end = new Date(endDate);
        
        if (start > end) {
          alert('Start date must be before or equal to end date.');
          return;
        }
        
        const { count, drinks: drinksToDelete } = getDrinksInDateRange(startDate, endDate);
        
        if (count === 0) {
          alert('No drinks found in the selected date range.');
          return;
        }
        
        // Check if offline
        if (!isOnline) {
          alert('You are offline. Bulk deletion requires an internet connection. Please try again when online.');
          return;
        }
        
        setDeleting(true);
        
        try {
          // Delete all drinks in the date range
          const drinkIds = drinksToDelete.map(d => d.id);
          
          // Supabase doesn't support bulk delete with array of IDs directly,
          // so we'll use .in() filter
          const { error } = await supabase
            .from('drinks')
            .delete()
            .in('id', drinkIds)
            .eq('user_id', user.id); // Ensure user can only delete their own drinks

          if (error) throw error;

          // Update local state
          const updatedDrinks = drinks.filter(d => !drinkIds.includes(d.id));
          setDrinks(updatedDrinks);
          
          // Update cache
          cacheDrinksData(updatedDrinks, user.id);
          
          // Reset pagination if needed
          const newTotalPages = Math.ceil(updatedDrinks.length / itemsPerPage);
          if (currentPage > newTotalPages && newTotalPages > 0) {
            setCurrentPage(newTotalPages);
          } else if (newTotalPages === 0) {
            setCurrentPage(1);
          }
          
          // Close modal and reset dates
          setShowBulkDelete(false);
          setDeleteStartDate('');
          setDeleteEndDate('');
          
          alert(`Successfully deleted ${count} drink${count === 1 ? '' : 's'}.`);
        } catch (error) {
          console.error('Error deleting drinks:', error);
          alert(`Failed to delete drinks: ${error.message}`);
        } finally {
          setDeleting(false);
        }
      };

      const deleteAllDrinks = async () => {
        if (!user) return;
        
        if (drinks.length === 0) {
          alert('No drinks to delete.');
          return;
        }
        
        // Double confirmation for deleting all
        const confirmMessage = `Are you sure you want to delete ALL ${drinks.length} drink${drinks.length === 1 ? '' : 's'}? This action cannot be undone.`;
        if (!confirm(confirmMessage)) {
          return;
        }
        
        // Check if offline
        if (!isOnline) {
          alert('You are offline. Deleting all drinks requires an internet connection. Please try again when online.');
          return;
        }
        
        setDeleting(true);
        
        try {
          const drinkCount = drinks.length;
          
          // Delete all drinks for this user - simpler approach that doesn't require ID array
          const { error } = await supabase
            .from('drinks')
            .delete()
            .eq('user_id', user.id); // RLS ensures user can only delete their own drinks

          if (error) throw error;

          // Update local state
          setDrinks([]);
          
          // Update cache
          cacheDrinksData([], user.id);
          
          // Reset pagination
          setCurrentPage(1);
          
          // Close modal
          setShowBulkDelete(false);
          setDeleteStartDate('');
          setDeleteEndDate('');
          
          alert(`Successfully deleted all ${drinkCount} drink${drinkCount === 1 ? '' : 's'}.`);
        } catch (error) {
          console.error('Error deleting all drinks:', error);
          alert(`Failed to delete all drinks: ${error.message}`);
        } finally {
          setDeleting(false);
        }
      };

      const removeFromQuickLog = (drinkName) => {
        const updated = quickLogDrinks.filter(d => d.name !== drinkName);
        setQuickLogDrinks(updated);
        saveQuickLog(updated);
      };

      const updateQuickLogDrink = (oldName, newName, newCategory) => {
        if (!newName.trim() || !newCategory) return;
        
        // Check for duplicates (excluding the drink being edited)
        const normalizedNewName = normalizeDrinkName(newName);
        const isDuplicate = quickLogDrinks.some(d => 
          normalizeDrinkName(d.name) === normalizedNewName && d.name !== oldName
        );
        
        if (isDuplicate) {
          alert('A drink with this name already exists in Quick Log.');
          return;
        }
        
        const updated = quickLogDrinks.map(d => 
          d.name === oldName ? { name: newName.trim(), category: newCategory } : d
        );
        setQuickLogDrinks(updated);
        saveQuickLog(updated);
        setEditingDrink(null);
        setEditName('');
        setEditCategory('');
      };

      const createNewQuickLogDrink = () => {
        if (!editName.trim() || !editCategory) {
          alert('Please enter a drink name and select a category.');
          return;
        }
        
        // Check for duplicates
        const normalizedNewName = normalizeDrinkName(editName);
        const isDuplicate = quickLogDrinks.some(d => 
          normalizeDrinkName(d.name) === normalizedNewName
        );
        
        if (isDuplicate) {
          alert('A drink with this name already exists in Quick Log.');
          return;
        }
        
        const updated = [...quickLogDrinks, { name: editName.trim(), category: editCategory }];
        setQuickLogDrinks(updated);
        saveQuickLog(updated);
        setEditingDrink(null);
        setEditName('');
        setEditCategory('');
      };

      const startEditingDrink = (drink) => {
        setEditingDrink(drink.name);
        setEditName(drink.name);
        setEditCategory(drink.category);
      };

      const startCreatingNewDrink = () => {
        setEditingDrink('__NEW__');
        setEditName('');
        setEditCategory('');
      };

      const addToQuickLog = (drinkName, category) => {
        const updated = [...quickLogDrinks, { name: drinkName, category: category }];
        setQuickLogDrinks(updated);
        saveQuickLog(updated);
      };

      const dismissSuggestion = (drinkName) => {
        const updated = [...dismissedSuggestions, normalizeDrinkName(drinkName)];
        setDismissedSuggestions(updated);
        saveDismissed(updated);
      };

      const getSuggestion = () => {
        const drinkCounts = {};
        
        drinks.forEach(drink => {
          const normalized = normalizeDrinkName(drink.name);
          const isInQuickLog = quickLogDrinks.some(qd => normalizeDrinkName(qd.name) === normalized);
          const isDismissed = dismissedSuggestions.includes(normalized);
          
          if (!isInQuickLog && !isDismissed) {
            if (!drinkCounts[normalized]) {
              drinkCounts[normalized] = { count: 0, originalName: drink.name, category: drink.category };
            }
            drinkCounts[normalized].count++;
          }
        });

        for (const [normalized, data] of Object.entries(drinkCounts)) {
          if (data.count >= 3) {
            return { name: data.originalName, category: data.category, count: data.count };
          }
        }
        return null;
      };

      const suggestion = getSuggestion();

      const exportToCSV = () => {
        if (drinks.length === 0) {
          alert('No drinks to export yet!');
          return;
        }

        const headers = ['Name', 'Category', 'Date', 'Time', 'Timestamp'];
        const rows = drinks.map(drink => {
          const date = new Date(drink.timestamp);
          const dateStr = date.toLocaleDateString('en-US');
          const timeStr = date.toLocaleTimeString('en-US');
          return [
            drink.name,
            drink.category,
            dateStr,
            timeStr,
            drink.timestamp
          ];
        });

        const csvContent = [
          headers.join(','),
          ...rows.map(row => row.map(cell => `"${cell}"`).join(','))
        ].join('\n');

        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement('a');
        const url = URL.createObjectURL(blob);
        link.setAttribute('href', url);
        link.setAttribute('download', `drink-tracker-${new Date().toISOString().split('T')[0]}.csv`);
        link.style.visibility = 'hidden';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      };

      const formatDate = (timestamp) => {
        const date = new Date(timestamp);
        const today = new Date();
        const yesterday = new Date(today);
        yesterday.setDate(yesterday.getDate() - 1);

        if (date.toDateString() === today.toDateString()) {
          return 'Today';
        } else if (date.toDateString() === yesterday.toDateString()) {
          return 'Yesterday';
        } else {
          return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
        }
      };

      const formatTime = (timestamp) => {
        return new Date(timestamp).toLocaleTimeString('en-US', { 
          hour: 'numeric', 
          minute: '2-digit',
          hour12: true 
        });
      };

      const getFilteredDrinks = () => {
        // Guard against undefined or null drinks array
        if (!drinks || !Array.isArray(drinks)) {
          return [];
        }
        let filtered = [...drinks];

        // Apply category filter
        if (dashboardCategoryFilter !== 'all') {
          filtered = filtered.filter(d => d.category === dashboardCategoryFilter);
        }

        // Apply search query
        if (dashboardSearchQuery.trim()) {
          const query = dashboardSearchQuery.toLowerCase().trim();
          filtered = filtered.filter(d => 
            d.name.toLowerCase().includes(query)
          );
        }

        // Apply date range based on preset period
        if (dashboardPresetPeriod !== 'all') {
          const now = new Date();
          const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
          
          let startDate, endDate;
          
          switch (dashboardPresetPeriod) {
            case 'thisWeek':
              // Start of this week (Sunday)
              const dayOfWeek = today.getDay();
              startDate = new Date(today);
              startDate.setDate(today.getDate() - dayOfWeek);
              startDate.setHours(0, 0, 0, 0);
              endDate = new Date(now);
              endDate.setHours(23, 59, 59, 999);
              break;
              
            case 'thisMonth':
              startDate = new Date(today.getFullYear(), today.getMonth(), 1);
              startDate.setHours(0, 0, 0, 0);
              endDate = new Date(now);
              endDate.setHours(23, 59, 59, 999);
              break;
              
            case 'last30Days':
              startDate = new Date(today);
              startDate.setDate(today.getDate() - 30);
              startDate.setHours(0, 0, 0, 0);
              endDate = new Date(now);
              endDate.setHours(23, 59, 59, 999);
              break;
              
            case 'thisYear':
              startDate = new Date(today.getFullYear(), 0, 1);
              startDate.setHours(0, 0, 0, 0);
              endDate = new Date(now);
              endDate.setHours(23, 59, 59, 999);
              break;
              
            default:
              return filtered;
          }
          
          filtered = filtered.filter(drink => {
            const drinkDate = new Date(drink.timestamp);
            return drinkDate >= startDate && drinkDate <= endDate;
          });
        }

        return filtered;
      };

      const calculateWeeklyStats = (filteredDrinks) => {
        if (!filteredDrinks || filteredDrinks.length === 0) {
          return [];
        }
        const weeklyMap = new Map();
        
        filteredDrinks.forEach(drink => {
          const date = new Date(drink.timestamp);
          const year = date.getFullYear();
          const weekStart = new Date(date);
          weekStart.setDate(date.getDate() - date.getDay()); // Start of week (Sunday)
          weekStart.setHours(0, 0, 0, 0);
          
          const weekKey = `${year}-W${getWeekNumber(weekStart)}`;
          
          if (!weeklyMap.has(weekKey)) {
            weeklyMap.set(weekKey, {
              week: weekKey,
              startDate: new Date(weekStart),
              count: 0,
              drinks: []
            });
          }
          
          const weekData = weeklyMap.get(weekKey);
          weekData.count++;
          weekData.drinks.push(drink);
        });
        
        return Array.from(weeklyMap.values()).sort((a, b) => 
          b.startDate.getTime() - a.startDate.getTime()
        );
      };

      const calculateMonthlyStats = (filteredDrinks) => {
        if (!filteredDrinks || filteredDrinks.length === 0) {
          return [];
        }
        const monthlyMap = new Map();
        
        filteredDrinks.forEach(drink => {
          const date = new Date(drink.timestamp);
          const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
          
          if (!monthlyMap.has(monthKey)) {
            monthlyMap.set(monthKey, {
              month: monthKey,
              monthName: date.toLocaleDateString('en-US', { month: 'long', year: 'numeric' }),
              count: 0,
              drinks: []
            });
          }
          
          const monthData = monthlyMap.get(monthKey);
          monthData.count++;
          monthData.drinks.push(drink);
        });
        
        return Array.from(monthlyMap.values()).sort((a, b) => 
          b.month.localeCompare(a.month)
        );
      };

      const calculateYearlyStats = (filteredDrinks) => {
        if (!filteredDrinks || filteredDrinks.length === 0) {
          return [];
        }
        const yearlyMap = new Map();
        
        filteredDrinks.forEach(drink => {
          const date = new Date(drink.timestamp);
          const year = date.getFullYear().toString();
          
          if (!yearlyMap.has(year)) {
            yearlyMap.set(year, {
              year: year,
              count: 0,
              drinks: []
            });
          }
          
          const yearData = yearlyMap.get(year);
          yearData.count++;
          yearData.drinks.push(drink);
        });
        
        return Array.from(yearlyMap.values()).sort((a, b) => 
          parseInt(b.year) - parseInt(a.year)
        );
      };

      const calculateDailyAverage = (filteredDrinks, period) => {
        if (!filteredDrinks || filteredDrinks.length === 0) return 0;
        
        const dates = filteredDrinks.map(d => {
          const date = new Date(d.timestamp);
          return new Date(date.getFullYear(), date.getMonth(), date.getDate()).getTime();
        });
        
        const uniqueDays = new Set(dates).size;
        
        if (uniqueDays === 0) return 0;
        
        return (filteredDrinks.length / uniqueDays).toFixed(2);
      };

      const calculateStreak = (filteredDrinks) => {
        if (!filteredDrinks || filteredDrinks.length === 0) {
          return { currentStreak: 0, longestStreak: 0, lastDrinkDate: null };
        }
        
        // Get unique dates
        const drinkDates = filteredDrinks.map(d => {
          const date = new Date(d.timestamp);
          return new Date(date.getFullYear(), date.getMonth(), date.getDate()).getTime();
        });
        
        const uniqueDates = Array.from(new Set(drinkDates)).sort((a, b) => b - a);
        
        // Calculate current streak (consecutive days from today backwards)
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        const todayTime = today.getTime();
        
        let currentStreak = 0;
        let checkDate = todayTime;
        
        while (uniqueDates.includes(checkDate)) {
          currentStreak++;
          checkDate -= 24 * 60 * 60 * 1000; // Subtract one day
        }
        
        // Calculate longest streak
        let longestStreak = 1;
        let tempStreak = 1;
        
        for (let i = 1; i < uniqueDates.length; i++) {
          const dayDiff = (uniqueDates[i - 1] - uniqueDates[i]) / (24 * 60 * 60 * 1000);
          if (dayDiff === 1) {
            tempStreak++;
            longestStreak = Math.max(longestStreak, tempStreak);
          } else {
            tempStreak = 1;
          }
        }
        
        return {
          currentStreak,
          longestStreak,
          lastDrinkDate: new Date(Math.max(...uniqueDates))
        };
      };

      const calculatePeakDays = (filteredDrinks) => {
        if (!filteredDrinks || filteredDrinks.length === 0) {
          const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
          return {
            dayOfWeek: {
              peak: 'N/A',
              count: 0,
              all: dayNames.map((name, idx) => ({ name, count: 0 }))
            },
            dayOfMonth: {
              peak: 0,
              count: 0,
              all: []
            }
          };
        }

        const dayOfWeekCount = { 0: 0, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0 }; // Sun-Sat
        const dayOfMonthCount = {};
        
        filteredDrinks.forEach(drink => {
          const date = new Date(drink.timestamp);
          const dayOfWeek = date.getDay();
          const dayOfMonth = date.getDate();
          
          dayOfWeekCount[dayOfWeek]++;
          
          if (!dayOfMonthCount[dayOfMonth]) {
            dayOfMonthCount[dayOfMonth] = 0;
          }
          dayOfMonthCount[dayOfMonth]++;
        });
        
        const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
        
        // Find peak day of week (with fallback)
        const peakDayOfWeek = Object.keys(dayOfWeekCount).length > 0
          ? Object.keys(dayOfWeekCount).reduce((a, b) => 
              dayOfWeekCount[a] > dayOfWeekCount[b] ? a : b
            )
          : '0';
        
        // Find peak day of month (with fallback)
        const peakDayOfMonth = Object.keys(dayOfMonthCount).length > 0
          ? Object.keys(dayOfMonthCount).reduce((a, b) => 
              dayOfMonthCount[a] > dayOfMonthCount[b] ? a : b
            )
          : '1';
        
        return {
          dayOfWeek: {
            peak: dayNames[parseInt(peakDayOfWeek)],
            count: dayOfWeekCount[peakDayOfWeek] || 0,
            all: dayNames.map((name, idx) => ({ name, count: dayOfWeekCount[idx] }))
          },
          dayOfMonth: {
            peak: parseInt(peakDayOfMonth),
            count: dayOfMonthCount[peakDayOfMonth] || 0,
            all: Object.keys(dayOfMonthCount).map(day => ({
              day: parseInt(day),
              count: dayOfMonthCount[day]
            })).sort((a, b) => a.day - b.day)
          }
        };
      };

      // Helper function to get week number
      const getWeekNumber = (date) => {
        const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
        const dayNum = d.getUTCDay() || 7;
        d.setUTCDate(d.getUTCDate() + 4 - dayNum);
        const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
        return Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
      };

      const calculateCalorieStats = (filteredDrinks) => {
        if (!filteredDrinks || filteredDrinks.length === 0) {
          return { total: 0, average: 0, drinksWithCalories: 0 };
        }
        
        const drinksWithCalories = filteredDrinks.filter(d => d.calories !== null && d.calories !== undefined);
        const total = drinksWithCalories.reduce((sum, d) => sum + (d.calories || 0), 0);
        const average = drinksWithCalories.length > 0 ? (total / drinksWithCalories.length).toFixed(1) : 0;
        
        return { total, average: parseFloat(average), drinksWithCalories: drinksWithCalories.length };
      };

      const calculateCostStats = (filteredDrinks) => {
        if (!filteredDrinks || filteredDrinks.length === 0) {
          return { total: 0, average: 0, drinksWithCost: 0 };
        }
        
        const drinksWithCost = filteredDrinks.filter(d => d.cost !== null && d.cost !== undefined);
        const total = drinksWithCost.reduce((sum, d) => sum + parseFloat(d.cost || 0), 0);
        const average = drinksWithCost.length > 0 ? (total / drinksWithCost.length).toFixed(2) : 0;
        
        return { total, average: parseFloat(average), drinksWithCost: drinksWithCost.length };
      };

      const getCalorieTrends = (filteredDrinks, period) => {
        if (!filteredDrinks || filteredDrinks.length === 0) return [];
        
        const drinksWithCalories = filteredDrinks.filter(d => d.calories !== null && d.calories !== undefined);
        const dailyMap = new Map();
        
        drinksWithCalories.forEach(drink => {
          const date = new Date(drink.timestamp);
          const dateKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;
          
          if (!dailyMap.has(dateKey)) {
            dailyMap.set(dateKey, { date: dateKey, calories: 0, count: 0 });
          }
          
          const dayData = dailyMap.get(dateKey);
          dayData.calories += drink.calories || 0;
          dayData.count++;
        });
        
        return Array.from(dailyMap.values()).sort((a, b) => a.date.localeCompare(b.date));
      };

      const getCostTrends = (filteredDrinks, period) => {
        if (!filteredDrinks || filteredDrinks.length === 0) return [];
        
        const drinksWithCost = filteredDrinks.filter(d => d.cost !== null && d.cost !== undefined);
        const dailyMap = new Map();
        
        drinksWithCost.forEach(drink => {
          const date = new Date(drink.timestamp);
          const dateKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;
          
          if (!dailyMap.has(dateKey)) {
            dailyMap.set(dateKey, { date: dateKey, cost: 0, count: 0 });
          }
          
          const dayData = dailyMap.get(dateKey);
          dayData.cost += parseFloat(drink.cost || 0);
          dayData.count++;
        });
        
        return Array.from(dailyMap.values()).sort((a, b) => a.date.localeCompare(b.date));
      };

      const getStats = () => {
        const filtered = getFilteredDrinks();
        const total = filtered.length;
        const beer = filtered.filter(d => d.category === 'Beer').length;
        const wine = filtered.filter(d => d.category === 'Wine').length;
        const cocktail = filtered.filter(d => d.category === 'Cocktail').length;
        return { total, beer, wine, cocktail };
      };

      const stats = getStats();
      const filteredDrinks = getFilteredDrinks();

      // Pagination calculations - use filtered drinks
      const totalPages = Math.ceil(filteredDrinks.length / itemsPerPage);
      const startIndex = (currentPage - 1) * itemsPerPage;
      const endIndex = startIndex + itemsPerPage;
      const paginatedDrinks = filteredDrinks.slice(startIndex, endIndex);

      // Reset to last valid page when filtered drinks change
      useEffect(() => {
        const newTotalPages = Math.ceil(filteredDrinks.length / itemsPerPage);
        if (currentPage > newTotalPages && newTotalPages > 0) {
          setCurrentPage(newTotalPages);
        } else if (newTotalPages === 0) {
          setCurrentPage(1);
        }
      }, [filteredDrinks.length, itemsPerPage, dashboardCategoryFilter, dashboardSearchQuery, dashboardPresetPeriod]);

      // Show loading while checking auth
      if (authLoading) {
        return (
          <div className="min-h-screen bg-gradient-to-br from-slate-900 via-purple-900 to-slate-900 text-white flex items-center justify-center">
            <div className="text-2xl">Loading...</div>
          </div>
        );
      }

      // Show auth UI if not logged in
      if (!user) {
        return (
          <div className="min-h-screen bg-gradient-to-br from-slate-900 via-purple-900 to-slate-900 text-white flex items-center justify-center p-6">
            <div className="max-w-md w-full">
              <div className="text-center mb-8">
                <h1 className="text-4xl font-bold mb-2">Drink Log</h1>
                <p className="text-slate-300">What are you drinking?</p>
              </div>

              {!showLogin && !showSignup && (
                <div className="bg-white/10 backdrop-blur rounded-2xl p-8 space-y-4">
                  <button
                    onClick={() => {
                      setShowSignup(true);
                      setShowLogin(false);
                      setAuthError('');
                    }}
                    className="w-full bg-purple-500 hover:bg-purple-600 rounded-lg py-3 font-semibold transition-colors"
                  >
                    Sign Up
                  </button>
                  <button
                    onClick={() => {
                      setShowLogin(true);
                      setShowSignup(false);
                      setAuthError('');
                    }}
                    className="w-full bg-white/10 hover:bg-white/20 rounded-lg py-3 font-semibold transition-colors border border-white/20"
                  >
                    Sign In
                  </button>
                </div>
              )}

              {(showLogin || showSignup) && (
                <div className="bg-white/10 backdrop-blur rounded-2xl p-8">
                  <h2 className="text-2xl font-bold mb-6 text-center">
                    {showSignup ? 'Create Account' : 'Sign In'}
                  </h2>
                  
                  {authError && (
                    <div className="bg-red-500/20 border border-red-500/50 rounded-lg p-3 mb-4 text-sm">
                      {authError}
                    </div>
                  )}

                  <form onSubmit={showSignup ? handleSignUp : handleSignIn} className="space-y-4">
                    <div>
                      <input
                        type="email"
                        placeholder="Email"
                        value={email}
                        onChange={(e) => setEmail(e.target.value)}
                        required
                        className="w-full bg-white/20 rounded-lg px-4 py-3 text-white placeholder-slate-400 outline-none focus:ring-2 focus:ring-purple-400"
                      />
                    </div>
                    <div>
                      <input
                        type="password"
                        placeholder="Password"
                        value={password}
                        onChange={(e) => setPassword(e.target.value)}
                        required
                        minLength={6}
                        className="w-full bg-white/20 rounded-lg px-4 py-3 text-white placeholder-slate-400 outline-none focus:ring-2 focus:ring-purple-400"
                      />
                    </div>
                    <button
                      type="submit"
                      className="w-full bg-purple-500 hover:bg-purple-600 rounded-lg py-3 font-semibold transition-colors"
                    >
                      {showSignup ? 'Sign Up' : 'Sign In'}
                    </button>
                  </form>

                  <button
                    onClick={() => {
                      setShowLogin(false);
                      setShowSignup(false);
                      setEmail('');
                      setPassword('');
                      setAuthError('');
                    }}
                    className="w-full mt-4 text-slate-300 hover:text-white text-sm transition-colors"
                  >
                    Back
                  </button>
                </div>
              )}
            </div>
          </div>
        );
      }

      // Show loading while loading data
      if (loading) {
        return (
          <div className="min-h-screen bg-gradient-to-br from-slate-900 via-purple-900 to-slate-900 text-white flex items-center justify-center">
            <div className="text-2xl">Loading your drinks...</div>
          </div>
        );
      }

      return (
        <div className="min-h-screen bg-gradient-to-br from-slate-900 via-purple-900 to-slate-900 text-white overflow-x-hidden">
          <div className="max-w-2xl mx-auto p-4 sm:p-6 pb-24 w-full">
            <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4 mb-8 pt-8">
              <div className="text-center sm:text-left flex-1">
                <h1 className="text-3xl sm:text-4xl font-bold mb-2">2026 Drink Tracker</h1>
                <p className="text-slate-300 text-sm sm:text-base">Track every drink, understand your habits</p>
              </div>
              <div className="flex items-center gap-3 flex-wrap justify-center sm:justify-end">
                {/* Offline/Syncing indicators */}
                {!isOnline && (
                  <div className="flex items-center gap-2 bg-yellow-500/20 border border-yellow-500/50 rounded-lg px-3 py-1.5 text-xs">
                    <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M18.364 5.636a9 9 0 010 12.728m0 0l-2.829-2.829m2.829 2.829L21 21M15.536 8.464a5 5 0 010 7.072m0 0l-2.829-2.829m-4.243 2.829a4.978 4.978 0 01-1.414-2.83m-1.414 5.658a9 9 0 01-2.167-9.238m7.824 2.167a1 1 0 111.414 1.414m-1.414-1.414L3 3m8.293 8.293l1.414 1.414" />
                    </svg>
                    <span className="hidden sm:inline">Offline</span>
                  </div>
                )}
                {isSyncing && (
                  <div className="flex items-center gap-2 bg-blue-500/20 border border-blue-500/50 rounded-lg px-3 py-1.5 text-xs">
                    <svg className="w-4 h-4 animate-spin" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                    </svg>
                    <span className="hidden sm:inline">Syncing...</span>
                  </div>
                )}
                {cacheTimestamp && isOnline && !isSyncing && (
                  <div className="text-xs text-slate-400 hidden lg:inline" title={`Last synced: ${new Date(cacheTimestamp).toLocaleTimeString()}`}>
                    {Math.floor((Date.now() - cacheTimestamp) / 1000 / 60) < 1 ? 'Just now' : `${Math.floor((Date.now() - cacheTimestamp) / 1000 / 60)}m ago`}
                  </div>
                )}
                <span className="text-sm text-slate-300 hidden sm:inline">{user.email}</span>
                <button
                  onClick={handleSignOut}
                  className="bg-white/10 hover:bg-white/20 rounded-lg px-4 py-2 text-sm font-semibold transition-colors flex items-center gap-2"
                >
                  <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M17 16l4-4m0 0l-4-4m4 4H7m6 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h4a3 3 0 013 3v1" />
                  </svg>
                  Sign Out
                </button>
              </div>
            </div>

            {suggestion && !editMode && (
              <div className="bg-green-500/20 border border-green-500/50 backdrop-blur rounded-xl p-4 mb-6 flex items-center justify-between">
                <div className="flex-1">
                  <div className="font-semibold">Add to Quick Log?</div>
                  <div className="text-sm text-slate-300">
                    You've logged "{suggestion.name}" {suggestion.count} times
                  </div>
                </div>
                <div className="flex gap-2">
                  <button
                    onClick={() => addToQuickLog(suggestion.name, suggestion.category)}
                    className="bg-green-500 hover:bg-green-600 px-4 py-2 rounded-lg font-semibold transition-colors"
                  >
                    Add
                  </button>
                  <button
                    onClick={() => dismissSuggestion(suggestion.name)}
                    className="bg-white/20 hover:bg-white/30 px-4 py-2 rounded-lg transition-colors"
                  >
                    Dismiss
                  </button>
                </div>
              </div>
            )}

            {/* Analytics Dashboard Section */}
            <div className="mb-6">
              <h2 className="text-2xl font-bold text-white mb-2">Analytics Dashboard</h2>
              <p className="text-sm text-slate-400 mb-4">View your drinking statistics and filter your history</p>
            </div>

            {/* Enhanced Dashboard */}
            <div className="bg-white/10 backdrop-blur rounded-2xl p-4 sm:p-6 mb-6 w-full overflow-hidden">
              {/* Filters and Period Selector */}
              <div className="mb-6 space-y-4">
                {/* Preset Period Buttons */}
                <div className="flex flex-wrap gap-2">
                  {['thisWeek', 'thisMonth', 'last30Days', 'thisYear', 'all'].map(period => {
                    const labels = {
                      thisWeek: 'This Week',
                      thisMonth: 'This Month',
                      last30Days: 'Last 30 Days',
                      thisYear: 'This Year',
                      all: 'All Time'
                    };
                    return (
                      <button
                        key={period}
                        onClick={() => setDashboardPresetPeriod(period)}
                        className={`px-4 py-2 rounded-lg font-semibold text-sm transition-colors ${
                          dashboardPresetPeriod === period
                            ? 'bg-purple-500 text-white'
                            : 'bg-white/10 hover:bg-white/20 text-slate-300'
                        }`}
                      >
                        {labels[period]}
                      </button>
                    );
                  })}
                </div>

                {/* Category Filter and Search */}
                <div className="flex flex-col sm:flex-row gap-3">
                  <select
                    value={dashboardCategoryFilter}
                    onChange={(e) => setDashboardCategoryFilter(e.target.value)}
                    className="w-full sm:flex-1 bg-white/10 border border-white/20 rounded-lg px-4 py-2 text-white focus:outline-none focus:ring-2 focus:ring-purple-400"
                  >
                    <option value="all">All Categories</option>
                    <option value="Beer">Beer</option>
                    <option value="Wine">Wine</option>
                    <option value="Cocktail">Cocktail</option>
                  </select>
                  <input
                    type="text"
                    placeholder="Filter by name..."
                    value={dashboardSearchQuery}
                    onChange={(e) => setDashboardSearchQuery(e.target.value)}
                    className="w-full sm:flex-1 bg-white/10 border border-white/20 rounded-lg px-4 py-2 text-white placeholder-slate-400 focus:outline-none focus:ring-2 focus:ring-purple-400"
                  />
                </div>
              </div>

              {/* Main Stats Card */}
              {(() => {
                const filtered = getFilteredDrinks();
                const dailyAvg = calculateDailyAverage(filtered, dashboardPresetPeriod);
                const streak = calculateStreak(filtered);
                const peakDays = calculatePeakDays(filtered);
                const weeklyStats = calculateWeeklyStats(filtered);
                const monthlyStats = calculateMonthlyStats(filtered);
                const yearlyStats = calculateYearlyStats(filtered);
                const calorieStats = calculateCalorieStats(filtered);
                const costStats = calculateCostStats(filtered);

                return (
                  <>
                    {/* Total and Category Breakdown */}
                    <div className="flex items-center justify-between mb-6">
                      <div>
                        <div className="text-slate-300 text-sm mb-1">Total Drinks</div>
                        <div className="text-5xl font-bold">{stats.total}</div>
                      </div>
                      <svg className="w-12 h-12 text-purple-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 7h8m0 0v8m0-8l-8 8-4-4-6 6" />
                      </svg>
                    </div>

                    <div className="grid grid-cols-3 gap-4 mb-6 pb-6 border-b border-white/20">
                      <div className="text-center">
                        <div className="text-2xl font-bold text-amber-400">{stats.beer}</div>
                        <div className="text-xs text-slate-300 mt-1">Beer</div>
                      </div>
                      <div className="text-center">
                        <div className="text-2xl font-bold text-pink-400">{stats.cocktail}</div>
                        <div className="text-xs text-slate-300 mt-1">Cocktail</div>
                      </div>
                      <div className="text-center">
                        <div className="text-2xl font-bold text-red-400">{stats.wine}</div>
                        <div className="text-xs text-slate-300 mt-1">Wine</div>
                      </div>
                    </div>

                    {/* Metrics Grid */}
                    <div className="grid grid-cols-2 gap-4 mb-6">
                      <div className="bg-white/5 rounded-xl p-4">
                        <div className="text-slate-400 text-xs mb-1">Daily Average</div>
                        <div className="text-2xl font-bold">{dailyAvg}</div>
                        <div className="text-xs text-slate-500 mt-1">drinks per day</div>
                      </div>
                      <div className="bg-white/5 rounded-xl p-4">
                        <div className="text-slate-400 text-xs mb-1">Current Streak</div>
                        <div className="text-2xl font-bold">{streak.currentStreak}</div>
                        <div className="text-xs text-slate-500 mt-1">consecutive days</div>
                      </div>
                      <div className="bg-white/5 rounded-xl p-4">
                        <div className="text-slate-400 text-xs mb-1">Longest Streak</div>
                        <div className="text-2xl font-bold">{streak.longestStreak}</div>
                        <div className="text-xs text-slate-500 mt-1">consecutive days</div>
                      </div>
                      <div className="bg-white/5 rounded-xl p-4">
                        <div className="text-slate-400 text-xs mb-1">Peak Day</div>
                        <div className="text-2xl font-bold">{peakDays.dayOfWeek.peak}</div>
                        <div className="text-xs text-slate-500 mt-1">{peakDays.dayOfWeek.count} drinks</div>
                      </div>
                    </div>

                    {/* Calorie and Cost Metrics */}
                    {(calorieStats.drinksWithCalories > 0 || costStats.drinksWithCost > 0) && (
                      <div className="grid grid-cols-2 gap-4 mb-6 pb-6 border-t border-white/20 pt-6">
                        {calorieStats.drinksWithCalories > 0 && (
                          <>
                            <div className="bg-white/5 rounded-xl p-4">
                              <div className="text-slate-400 text-xs mb-1">Total Calories</div>
                              <div className="text-2xl font-bold text-orange-400">{calorieStats.total.toLocaleString()}</div>
                              <div className="text-xs text-slate-500 mt-1">avg {calorieStats.average} per drink</div>
                            </div>
                            <div className="bg-white/5 rounded-xl p-4">
                              <div className="text-slate-400 text-xs mb-1">Total Cost</div>
                              <div className="text-2xl font-bold text-green-400">${costStats.total.toFixed(2)}</div>
                              <div className="text-xs text-slate-500 mt-1">avg ${costStats.average} per drink</div>
                            </div>
                          </>
                        )}
                      </div>
                    )}

                    {/* Calorie and Cost Trends */}
                    {(calorieStats.drinksWithCalories > 0 || costStats.drinksWithCost > 0) && (
                      <div className="mb-6 pb-6 border-b border-white/20">
                        <h3 className="text-lg font-semibold text-slate-300 mb-4">Calories & Cost Trends</h3>
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                          {calorieStats.drinksWithCalories > 0 && (() => {
                            const calorieTrends = getCalorieTrends(filtered, dashboardPresetPeriod);
                            const maxCalories = calorieTrends.length > 0 ? Math.max(...calorieTrends.map(t => t.calories)) : 0;
                            return (
                              <div>
                                <div className="text-sm text-slate-400 mb-2">Daily Calories</div>
                                <div className="space-y-2">
                                  {calorieTrends.slice(-7).map((day, idx) => {
                                    const percentage = maxCalories > 0 ? (day.calories / maxCalories) * 100 : 0;
                                    return (
                                      <div key={idx} className="flex items-center gap-3">
                                        <div className="text-xs text-slate-400 w-20">
                                          {new Date(day.date).toLocaleDateString('en-US', { month: 'short', day: 'numeric' })}
                                        </div>
                                        <div className="flex-1 bg-white/10 rounded-full h-6 relative overflow-hidden">
                                          <div
                                            className="bg-orange-500 h-full rounded-full transition-all"
                                            style={{ width: `${percentage}%` }}
                                          />
                                          <div className="absolute inset-0 flex items-center justify-center text-xs font-semibold">
                                            {day.calories}
                                          </div>
                                        </div>
                                      </div>
                                    );
                                  })}
                                </div>
                              </div>
                            );
                          })()}
                          {costStats.drinksWithCost > 0 && (() => {
                            const costTrends = getCostTrends(filtered, dashboardPresetPeriod);
                            const maxCost = costTrends.length > 0 ? Math.max(...costTrends.map(t => t.cost)) : 0;
                            return (
                              <div>
                                <div className="text-sm text-slate-400 mb-2">Daily Cost</div>
                                <div className="space-y-2">
                                  {costTrends.slice(-7).map((day, idx) => {
                                    const percentage = maxCost > 0 ? (day.cost / maxCost) * 100 : 0;
                                    return (
                                      <div key={idx} className="flex items-center gap-3">
                                        <div className="text-xs text-slate-400 w-20">
                                          {new Date(day.date).toLocaleDateString('en-US', { month: 'short', day: 'numeric' })}
                                        </div>
                                        <div className="flex-1 bg-white/10 rounded-full h-6 relative overflow-hidden">
                                          <div
                                            className="bg-green-500 h-full rounded-full transition-all"
                                            style={{ width: `${percentage}%` }}
                                          />
                                          <div className="absolute inset-0 flex items-center justify-center text-xs font-semibold">
                                            ${day.cost.toFixed(2)}
                                          </div>
                                        </div>
                                      </div>
                                    );
                                  })}
                                </div>
                              </div>
                            );
                          })()}
                        </div>
                      </div>
                    )}

                    {/* Time Series Display */}
                    {dashboardPeriod === 'week' && weeklyStats.length > 0 && (
                      <div className="mb-6">
                        <h3 className="text-lg font-semibold text-slate-300 mb-3">Weekly Breakdown</h3>
                        <div className="space-y-2">
                          {weeklyStats.slice(0, 8).map(week => {
                            const counts = weeklyStats.map(w => w.count);
                            const maxCount = counts.length > 0 ? Math.max(...counts) : 0;
                            const percentage = maxCount > 0 ? (week.count / maxCount) * 100 : 0;
                            return (
                              <div key={week.week} className="flex items-center gap-3">
                                <div className="text-xs text-slate-400 w-20">
                                  {week.startDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric' })}
                                </div>
                                <div className="flex-1 bg-white/10 rounded-full h-6 relative overflow-hidden">
                                  <div
                                    className="bg-purple-500 h-full rounded-full transition-all"
                                    style={{ width: `${percentage}%` }}
                                  />
                                  <div className="absolute inset-0 flex items-center justify-center text-xs font-semibold">
                                    {week.count}
                                  </div>
                                </div>
                              </div>
                            );
                          })}
                        </div>
                      </div>
                    )}

                    {dashboardPeriod === 'month' && monthlyStats.length > 0 && (
                      <div className="mb-6">
                        <h3 className="text-lg font-semibold text-slate-300 mb-3">Monthly Breakdown</h3>
                        <div className="space-y-2">
                          {monthlyStats.slice(0, 12).map(month => {
                            const counts = monthlyStats.map(m => m.count);
                            const maxCount = counts.length > 0 ? Math.max(...counts) : 0;
                            const percentage = maxCount > 0 ? (month.count / maxCount) * 100 : 0;
                            return (
                              <div key={month.month} className="flex items-center gap-3">
                                <div className="text-xs text-slate-400 w-32">{month.monthName}</div>
                                <div className="flex-1 bg-white/10 rounded-full h-6 relative overflow-hidden">
                                  <div
                                    className="bg-purple-500 h-full rounded-full transition-all"
                                    style={{ width: `${percentage}%` }}
                                  />
                                  <div className="absolute inset-0 flex items-center justify-center text-xs font-semibold">
                                    {month.count}
                                  </div>
                                </div>
                              </div>
                            );
                          })}
                        </div>
                      </div>
                    )}

                    {dashboardPeriod === 'year' && yearlyStats.length > 0 && (
                      <div className="mb-6">
                        <h3 className="text-lg font-semibold text-slate-300 mb-3">Yearly Breakdown</h3>
                        <div className="space-y-2">
                          {yearlyStats.map(year => {
                            const counts = yearlyStats.map(y => y.count);
                            const maxCount = counts.length > 0 ? Math.max(...counts) : 0;
                            const percentage = maxCount > 0 ? (year.count / maxCount) * 100 : 0;
                            return (
                              <div key={year.year} className="flex items-center gap-3">
                                <div className="text-xs text-slate-400 w-20">{year.year}</div>
                                <div className="flex-1 bg-white/10 rounded-full h-6 relative overflow-hidden">
                                  <div
                                    className="bg-purple-500 h-full rounded-full transition-all"
                                    style={{ width: `${percentage}%` }}
                                  />
                                  <div className="absolute inset-0 flex items-center justify-center text-xs font-semibold">
                                    {year.count}
                                  </div>
                                </div>
                              </div>
                            );
                          })}
                        </div>
                      </div>
                    )}

                    {/* Period Selector Tabs */}
                    <div className="flex gap-2 border-t border-white/20 pt-4">
                      {['week', 'month', 'year'].map(period => (
                        <button
                          key={period}
                          onClick={() => setDashboardPeriod(period)}
                          className={`px-4 py-2 rounded-lg font-semibold text-sm transition-colors capitalize ${
                            dashboardPeriod === period
                              ? 'bg-purple-500 text-white'
                              : 'bg-white/10 hover:bg-white/20 text-slate-300'
                          }`}
                        >
                          {period}
                        </button>
                      ))}
                    </div>
                  </>
                );
              })()}
            </div>

            {/* Visual Separator */}
            <div className="my-8 border-t border-white/10"></div>

            {/* Quick Log Section - Secondary Option */}
            <div className="mb-6">
              <div className="flex items-center justify-between mb-3">
                <div>
                  <h2 className="text-lg font-semibold text-slate-400">Quick Log</h2>
                  <p className="text-xs text-slate-500 mt-1">Frequently used drinks for quick access</p>
                </div>
                <button
                  onClick={() => {
                    setEditMode(!editMode);
                    setEditingDrink(null);
                    setEditName('');
                    setEditCategory('');
                  }}
                  className="text-sm text-purple-400 hover:text-purple-300 flex items-center gap-1"
                >
                  <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" />
                  </svg>
                  {editMode ? 'Done' : 'Edit'}
                </button>
              </div>

              {/* Prominent "Log a Drink" Button */}
              {!editMode && (
                <button
                  onClick={() => {
                    setShowOtherForm(true);
                    setFreeformText('');
                    setParsedDrinks([]);
                    setFreeformDateTime(null);
                    setShowFreeformDateTime(false);
                  }}
                  className="w-full bg-purple-500 hover:bg-purple-600 text-white rounded-xl py-4 font-semibold transition-all hover:scale-[1.02] active:scale-[0.98] flex items-center justify-center gap-2 mb-4 shadow-lg"
                  style={{ boxShadow: '0 4px 15px rgba(168, 85, 247, 0.3)' }}
                >
                  <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2.5} d="M12 4v16m8-8H4" />
                  </svg>
                  Log a Drink
                </button>
              )}

              {editingDrink && (
                <div className="bg-white/10 backdrop-blur rounded-xl p-4 mb-3">
                  <div className="text-sm font-semibold mb-3">
                    {editingDrink === '__NEW__' ? 'Create New Quick Log Button' : 'Edit Drink'}
                  </div>
                  <input
                    type="text"
                    value={editName}
                    onChange={(e) => setEditName(e.target.value)}
                    className="w-full bg-white/20 rounded-lg px-4 py-3 mb-3 text-white placeholder-slate-400 outline-none focus:ring-2 focus:ring-purple-400"
                    placeholder="Drink name"
                    autoFocus
                  />
                  <div className="text-sm text-slate-300 mb-2">Category:</div>
                  <div className="flex gap-2 mb-3">
                    <button
                      onClick={() => setEditCategory('Beer')}
                      className={`flex-1 border rounded-lg py-2 font-semibold transition-colors ${
                        editCategory === 'Beer' 
                          ? 'bg-amber-500 border-amber-500' 
                          : 'bg-amber-500/20 border-amber-500/50 hover:bg-amber-500/40'
                      }`}
                    >
                      Beer
                    </button>
                    <button
                      onClick={() => setEditCategory('Cocktail')}
                      className={`flex-1 border rounded-lg py-2 font-semibold transition-colors ${
                        editCategory === 'Cocktail' 
                          ? 'bg-pink-500 border-pink-500' 
                          : 'bg-pink-500/20 border-pink-500/50 hover:bg-pink-500/40'
                      }`}
                    >
                      Cocktail
                    </button>
                    <button
                      onClick={() => setEditCategory('Wine')}
                      className={`flex-1 border rounded-lg py-2 font-semibold transition-colors ${
                        editCategory === 'Wine' 
                          ? 'bg-red-500 border-red-500' 
                          : 'bg-red-500/20 border-red-500/50 hover:bg-red-500/40'
                      }`}
                    >
                      Wine
                    </button>
                  </div>
                  <div className="flex gap-2">
                    <button
                      onClick={() => {
                        if (editingDrink === '__NEW__') {
                          createNewQuickLogDrink();
                        } else {
                          updateQuickLogDrink(editingDrink, editName, editCategory);
                        }
                      }}
                      className="flex-1 bg-purple-500 hover:bg-purple-600 rounded-lg py-2 font-semibold transition-colors"
                    >
                      {editingDrink === '__NEW__' ? 'Create' : 'Save'}
                    </button>
                    <button
                      onClick={() => {
                        setEditingDrink(null);
                        setEditName('');
                        setEditCategory('');
                      }}
                      className="px-6 bg-white/20 hover:bg-white/30 rounded-lg transition-colors"
                    >
                      Cancel
                    </button>
                  </div>
                </div>
              )}

              <div className="grid grid-cols-2 gap-3 mb-3">
                {quickLogDrinks.map((drink) => (
                  <div key={drink.name} className="relative">
                    <button
                      onClick={() => {
                        if (editMode) {
                          startEditingDrink(drink);
                        } else {
                          // Open date/time selector for quick log
                          setPendingQuickLogDrink(drink);
                          setQuickLogDateTime({ preset: 'now', date: '', time: '' });
                          setShowQuickLogDateTime(true);
                        }
                      }}
                      className={`w-full bg-white/10 backdrop-blur rounded-xl py-3 font-semibold transition-all ${
                        editMode ? 'hover:bg-white/20 ring-2 ring-purple-400/50' : 'hover:bg-purple-500 hover:scale-105 active:scale-95'
                      }`}
                    >
                      <div>{drink.name}</div>
                      <div className="text-xs text-slate-300 mt-1">{drink.category}</div>
                    </button>
                    {editMode && (
                      <button
                        onClick={() => removeFromQuickLog(drink.name)}
                        className="absolute -top-2 -right-2 bg-red-500 hover:bg-red-600 rounded-full p-1 shadow-lg"
                      >
                        <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                        </svg>
                      </button>
                    )}
                  </div>
                ))}
                
                {/* Add New Button - only shown in edit mode */}
                {editMode && !editingDrink && (
                  <button
                    onClick={startCreatingNewDrink}
                    className="w-full bg-white/10 backdrop-blur rounded-xl py-3 font-semibold transition-all hover:bg-white/20 ring-2 ring-dashed ring-purple-400/50 border-2 border-dashed border-purple-400/30 flex items-center justify-center gap-2"
                  >
                    <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" />
                    </svg>
                    <span>Add New</span>
                  </button>
                )}
              </div>
            </div>

            {/* Quick Log Date/Time Modal */}
            {showQuickLogDateTime && pendingQuickLogDrink && (
              <div className="fixed inset-0 bg-black/50 backdrop-blur-sm flex items-center justify-center z-50 p-4">
                <div className="bg-slate-800 rounded-2xl p-6 max-w-md w-full">
                  <div className="flex items-center justify-between mb-4">
                    <h3 className="text-xl font-semibold text-white">Log {pendingQuickLogDrink.name}</h3>
                    <button
                      onClick={() => {
                        setShowQuickLogDateTime(false);
                        setPendingQuickLogDrink(null);
                        setQuickLogDateTime(null);
                      }}
                      className="text-slate-400 hover:text-white transition-colors"
                    >
                      <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                      </svg>
                    </button>
                  </div>
                  <div className="space-y-4">
                    <div>
                      <label className="text-xs text-slate-400 mb-2 block">Date & Time</label>
                      <div className="flex flex-wrap gap-2 mb-2">
                        {['now', 'yesterday', 'lastNight', 'custom'].map(preset => (
                          <button
                            key={preset}
                            onClick={() => {
                              if (preset === 'custom') {
                                setQuickLogDateTime({ preset: 'custom', date: '', time: '' });
                              } else {
                                const presetDateTime = applyDateTimePreset(preset);
                                if (presetDateTime) {
                                  const date = new Date(presetDateTime);
                                  setQuickLogDateTime({
                                    preset: preset,
                                    date: date.toISOString().split('T')[0],
                                    time: date.toTimeString().slice(0, 5)
                                  });
                                }
                              }
                            }}
                            className={`px-3 py-1.5 rounded-lg text-sm font-semibold transition-colors ${
                              quickLogDateTime?.preset === preset
                                ? 'bg-purple-500 text-white'
                                : 'bg-white/10 hover:bg-white/20 text-slate-300'
                            }`}
                          >
                            {preset === 'now' ? 'Now' : preset === 'yesterday' ? 'Yesterday' : preset === 'lastNight' ? 'Last Night' : 'Custom'}
                          </button>
                        ))}
                      </div>
                      {quickLogDateTime?.preset === 'custom' && (
                        <div className="flex gap-2">
                          <input
                            type="date"
                            value={quickLogDateTime.date || ''}
                            onChange={(e) => setQuickLogDateTime({ ...quickLogDateTime, date: e.target.value })}
                            className="flex-1 bg-white/10 border border-white/20 rounded-lg px-3 py-2 text-white focus:outline-none focus:ring-2 focus:ring-purple-400"
                          />
                          <input
                            type="time"
                            value={quickLogDateTime.time || ''}
                            onChange={(e) => setQuickLogDateTime({ ...quickLogDateTime, time: e.target.value })}
                            className="flex-1 bg-white/10 border border-white/20 rounded-lg px-3 py-2 text-white focus:outline-none focus:ring-2 focus:ring-purple-400"
                          />
                        </div>
                      )}
                    </div>
                    <div className="flex gap-3 pt-2">
                      <button
                        onClick={async () => {
                          let timestamp;
                          if (quickLogDateTime) {
                            if (quickLogDateTime.preset === 'custom' && quickLogDateTime.date) {
                              timestamp = parseDateTimeInput(quickLogDateTime.date, quickLogDateTime.time) || new Date().toISOString();
                            } else if (quickLogDateTime.preset !== 'custom') {
                              const presetDateTime = applyDateTimePreset(quickLogDateTime.preset);
                              timestamp = presetDateTime || new Date().toISOString();
                            } else {
                              timestamp = new Date().toISOString();
                            }
                          } else {
                            timestamp = new Date().toISOString();
                          }
                          
                          // Create a temporary drink object with the timestamp
                          const drinkWithTimestamp = {
                            name: pendingQuickLogDrink.name,
                            category: pendingQuickLogDrink.category,
                            timestamp: timestamp
                          };
                          
                          // Use quickAddDrink but we need to modify it to accept timestamp
                          // For now, we'll call it and then update the timestamp
                          await quickAddDrinkWithTimestamp(pendingQuickLogDrink.name, pendingQuickLogDrink.category, timestamp);
                          
                          setShowQuickLogDateTime(false);
                          setPendingQuickLogDrink(null);
                          setQuickLogDateTime(null);
                        }}
                        className="flex-1 bg-purple-500 hover:bg-purple-600 rounded-lg py-2 font-semibold transition-colors"
                      >
                        Log Drink
                      </button>
                      <button
                        onClick={() => {
                          setShowQuickLogDateTime(false);
                          setPendingQuickLogDrink(null);
                          setQuickLogDateTime(null);
                        }}
                        className="px-6 bg-white/10 hover:bg-white/20 rounded-lg py-2 transition-colors"
                      >
                        Cancel
                      </button>
                    </div>
                  </div>
                </div>
              </div>
            )}

            <div className="space-y-3">
              <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-3 mb-3">
                <div className="flex items-center gap-3 flex-wrap">
                  <h2 className="text-lg font-semibold text-slate-300">History</h2>
                  {drinks.length > 0 && (
                    <span className="text-xs text-slate-400 bg-white/10 px-2 py-1 rounded">
                      {filteredDrinks.length === drinks.length 
                        ? `${filteredDrinks.length} ${filteredDrinks.length === 1 ? 'drink' : 'drinks'}`
                        : `${filteredDrinks.length} of ${drinks.length} ${drinks.length === 1 ? 'drink' : 'drinks'}`
                      }
                    </span>
                  )}
                </div>
                {drinks.length > 0 && (
                  <div className="flex items-center gap-2 flex-wrap">
                    <button
                      onClick={() => setShowBulkDelete(true)}
                      className="text-sm text-red-400 hover:text-red-300 flex items-center gap-1 bg-white/10 hover:bg-white/20 px-3 py-1.5 rounded-lg transition-colors"
                    >
                      <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                      </svg>
                      Bulk Delete
                    </button>
                    <button
                      onClick={exportToCSV}
                      className="text-sm text-purple-400 hover:text-purple-300 flex items-center gap-1 bg-white/10 hover:bg-white/20 px-3 py-1.5 rounded-lg transition-colors"
                    >
                      Export CSV
                    </button>
                  </div>
                )}
              </div>
              {drinks.length === 0 ? (
                <div className="text-center py-12 text-slate-400">
                  <svg className="w-16 h-16 mx-auto mb-4 opacity-50" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z" />
                  </svg>
                  <p>No drinks logged yet</p>
                  <p className="text-sm mt-2">Tap a button above to start tracking</p>
                </div>
              ) : filteredDrinks.length === 0 ? (
                <div className="text-center py-12 text-slate-400">
                  <svg className="w-16 h-16 mx-auto mb-4 opacity-50" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
                  </svg>
                  <p>No drinks match your filters</p>
                  <p className="text-sm mt-2">Try adjusting your search or filter settings</p>
                </div>
              ) : (
                <>
                  {paginatedDrinks.map((drink) => (
                    <div
                      key={drink.id}
                      className="bg-white/10 backdrop-blur rounded-xl p-4 flex items-center justify-between hover:bg-white/15 transition-colors cursor-pointer"
                      onClick={() => openDrinkDetail(drink)}
                    >
                      <div className="flex-1">
                        <div className="font-semibold text-lg">{drink.name}</div>
                        <div className="text-slate-300 text-sm">
                          {drink.category} • {formatDate(drink.timestamp)} at {formatTime(drink.timestamp)}
                        </div>
                      </div>
                      <button
                        onClick={(e) => {
                          e.stopPropagation();
                          deleteDrink(drink.id);
                        }}
                        className="text-red-400 hover:text-red-300 text-sm px-3 py-1 rounded-lg hover:bg-white/10 transition-colors"
                      >
                        Delete
                      </button>
                    </div>
                  ))}
                  
                  {/* Pagination Controls */}
                  {totalPages > 1 && (
                    <div className="flex items-center justify-center gap-2 mt-6 pt-6 border-t border-white/20">
                      <button
                        onClick={() => setCurrentPage(prev => Math.max(1, prev - 1))}
                        disabled={currentPage === 1}
                        className={`px-4 py-2 rounded-lg font-semibold transition-colors flex items-center gap-1 ${
                          currentPage === 1
                            ? 'bg-white/5 text-slate-500 cursor-not-allowed'
                            : 'bg-white/10 hover:bg-white/20 text-white'
                        }`}
                      >
                        <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 19l-7-7 7-7" />
                        </svg>
                        Previous
                      </button>
                      
                      <div className="flex items-center gap-1">
                        {Array.from({ length: totalPages }, (_, i) => i + 1).map((page) => {
                          // Show first page, last page, current page, and pages around current
                          if (
                            page === 1 ||
                            page === totalPages ||
                            (page >= currentPage - 1 && page <= currentPage + 1)
                          ) {
                            return (
                              <button
                                key={page}
                                onClick={() => setCurrentPage(page)}
                                className={`min-w-[2.5rem] px-3 py-2 rounded-lg font-semibold transition-colors ${
                                  currentPage === page
                                    ? 'bg-purple-500 text-white'
                                    : 'bg-white/10 hover:bg-white/20 text-white'
                                }`}
                              >
                                {page}
                              </button>
                            );
                          } else if (
                            page === currentPage - 2 ||
                            page === currentPage + 2
                          ) {
                            return (
                              <span key={page} className="px-2 text-slate-400">
                                ...
                              </span>
                            );
                          }
                          return null;
                        })}
                      </div>
                      
                      <button
                        onClick={() => setCurrentPage(prev => Math.min(totalPages, prev + 1))}
                        disabled={currentPage === totalPages}
                        className={`px-4 py-2 rounded-lg font-semibold transition-colors flex items-center gap-1 ${
                          currentPage === totalPages
                            ? 'bg-white/5 text-slate-500 cursor-not-allowed'
                            : 'bg-white/10 hover:bg-white/20 text-white'
                        }`}
                      >
                        Next
                        <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" />
                        </svg>
                      </button>
                    </div>
                  )}
                  
                  {/* Page info */}
                  {totalPages > 1 && (
                    <div className="text-center text-sm text-slate-400 mt-2">
                      Showing {startIndex + 1}-{Math.min(endIndex, filteredDrinks.length)} of {filteredDrinks.length} drinks
                    </div>
                  )}
                </>
              )}
            </div>

            {/* Bulk Delete Modal */}
            {showBulkDelete && (
              <div className="fixed inset-0 bg-black/50 backdrop-blur-sm flex items-center justify-center z-50 p-4">
                <div className="bg-slate-800 rounded-2xl p-6 max-w-md w-full max-h-[90vh] overflow-y-auto">
                  <div className="flex items-center justify-between mb-4">
                    <h3 className="text-xl font-semibold text-white">Bulk Delete Drinks</h3>
                    <button
                      onClick={() => {
                        setShowBulkDelete(false);
                        setDeleteStartDate('');
                        setDeleteEndDate('');
                      }}
                      className="text-slate-400 hover:text-white transition-colors"
                      disabled={deleting}
                    >
                      <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                      </svg>
                    </button>
                  </div>

                  <div className="space-y-4">
                    {/* Delete All Option */}
                    <div className="bg-red-500/10 border border-red-500/30 rounded-lg p-4">
                      <div className="text-red-400 font-semibold mb-2">Delete All Drinks</div>
                      <div className="text-sm text-slate-300 mb-3">
                        This will permanently delete all {drinks.length} drink{drinks.length === 1 ? '' : 's'} in your account. This action cannot be undone.
                      </div>
                      <button
                        onClick={deleteAllDrinks}
                        disabled={deleting || drinks.length === 0}
                        className="w-full bg-red-500 hover:bg-red-600 disabled:bg-red-500/50 disabled:cursor-not-allowed rounded-lg py-2 font-semibold transition-colors flex items-center justify-center gap-2"
                      >
                        {deleting ? (
                          <>
                            <svg className="animate-spin h-4 w-4" fill="none" viewBox="0 0 24 24">
                              <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                              <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                            </svg>
                            Deleting...
                          </>
                        ) : (
                          'Delete All'
                        )}
                      </button>
                    </div>

                    <div className="relative">
                      <div className="absolute inset-0 flex items-center">
                        <div className="w-full border-t border-white/20"></div>
                      </div>
                      <div className="relative flex justify-center text-sm">
                        <span className="px-2 bg-slate-800 text-slate-400">OR</span>
                      </div>
                    </div>

                    <div>
                      <label className="block text-sm text-slate-300 mb-2">Start Date</label>
                      <input
                        type="date"
                        value={deleteStartDate}
                        onChange={(e) => setDeleteStartDate(e.target.value)}
                        className="w-full bg-white/10 border border-white/20 rounded-lg px-4 py-2 text-white focus:outline-none focus:ring-2 focus:ring-purple-400"
                        disabled={deleting}
                      />
                    </div>

                    <div>
                      <label className="block text-sm text-slate-300 mb-2">End Date</label>
                      <input
                        type="date"
                        value={deleteEndDate}
                        onChange={(e) => setDeleteEndDate(e.target.value)}
                        className="w-full bg-white/10 border border-white/20 rounded-lg px-4 py-2 text-white focus:outline-none focus:ring-2 focus:ring-purple-400"
                        disabled={deleting}
                      />
                    </div>

                    {/* Preview */}
                    {deleteStartDate && deleteEndDate && (
                      <div className="bg-red-500/10 border border-red-500/30 rounded-lg p-4">
                        <div className="text-red-400 font-semibold mb-2">
                          {(() => {
                            const { count } = getDrinksInDateRange(deleteStartDate, deleteEndDate);
                            return count > 0 
                              ? `${count} drink${count === 1 ? '' : 's'} will be deleted`
                              : 'No drinks found in this date range';
                          })()}
                        </div>
                        {(() => {
                          const { count, drinks: previewDrinks } = getDrinksInDateRange(deleteStartDate, deleteEndDate);
                          if (count > 0 && count <= 5) {
                            return (
                              <div className="text-sm text-slate-300 space-y-1">
                                {previewDrinks.slice(0, 5).map(drink => (
                                  <div key={drink.id}>
                                    {drink.name} • {formatDate(drink.timestamp)}
                                  </div>
                                ))}
                              </div>
                            );
                          } else if (count > 5) {
                            return (
                              <div className="text-sm text-slate-300">
                                Showing first 5 of {count} drinks...
                              </div>
                            );
                          }
                          return null;
                        })()}
                      </div>
                    )}

                    <div className="flex gap-3 pt-2">
                      <button
                        onClick={() => {
                          setShowBulkDelete(false);
                          setDeleteStartDate('');
                          setDeleteEndDate('');
                        }}
                        className="flex-1 bg-white/10 hover:bg-white/20 rounded-lg py-2 font-semibold transition-colors"
                        disabled={deleting}
                      >
                        Cancel
                      </button>
                      <button
                        onClick={() => deleteDrinksByDateRange(deleteStartDate, deleteEndDate)}
                        disabled={deleting || !deleteStartDate || !deleteEndDate || getDrinksInDateRange(deleteStartDate, deleteEndDate).count === 0}
                        className="flex-1 bg-red-500 hover:bg-red-600 disabled:bg-red-500/50 disabled:cursor-not-allowed rounded-lg py-2 font-semibold transition-colors flex items-center justify-center gap-2"
                      >
                        {deleting ? (
                          <>
                            <svg className="animate-spin h-4 w-4" fill="none" viewBox="0 0 24 24">
                              <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                              <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                            </svg>
                            Deleting...
                          </>
                        ) : (
                          'Delete'
                        )}
                      </button>
                    </div>
                  </div>
                </div>
              </div>
            )}

            {/* Drink Detail/Edit Modal */}
            {showDrinkDetail && editingDrinkDetail && (
              <div className="fixed inset-0 bg-black/50 backdrop-blur-sm flex items-center justify-center z-50 p-4">
                <div className="bg-slate-800 rounded-2xl p-6 max-w-md w-full max-h-[90vh] overflow-y-auto">
                  <div className="flex items-center justify-between mb-4">
                    <h3 className="text-xl font-semibold text-white">Drink Details</h3>
                    <button
                      onClick={() => {
                        setShowDrinkDetail(false);
                        setSelectedDrink(null);
                        setEditingDrinkDetail(null);
                      }}
                      className="text-slate-400 hover:text-white transition-colors"
                    >
                      <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                      </svg>
                    </button>
                  </div>

                  <div className="space-y-4">
                    {/* Read-only Fields */}
                    <div className="space-y-2 pb-4 border-b border-white/10">
                      <div>
                        <label className="text-xs text-slate-400 mb-1 block">Name</label>
                        <div className="text-white font-semibold">{editingDrinkDetail.name}</div>
                      </div>
                      <div>
                        <label className="text-xs text-slate-400 mb-1 block">Category</label>
                        <div className="text-white">{editingDrinkDetail.category}</div>
                      </div>
                      {selectedDrink && (
                        <div>
                          <label className="text-xs text-slate-400 mb-1 block">Created</label>
                          <div className="text-slate-300 text-sm">{formatDateTimeForDisplay(selectedDrink.timestamp)}</div>
                        </div>
                      )}
                    </div>

                    {/* Editable Fields */}
                    <div className="space-y-4">
                      {/* Date/Time */}
                      <div>
                        <label className="text-xs text-slate-400 mb-2 block">Date & Time</label>
                        <div className="flex flex-wrap gap-2 mb-2">
                          {['now', 'yesterday', 'lastNight', 'custom'].map(preset => (
                            <button
                              key={preset}
                              onClick={() => {
                                if (preset === 'custom') {
                                  setEditingDrinkDetail({ ...editingDrinkDetail, editDateTimePreset: 'custom' });
                                } else {
                                  const presetDateTime = applyDateTimePreset(preset);
                                  if (presetDateTime) {
                                    const date = new Date(presetDateTime);
                                    setEditingDrinkDetail({
                                      ...editingDrinkDetail,
                                      editDate: date.toISOString().split('T')[0],
                                      editTime: date.toTimeString().slice(0, 5),
                                      editDateTimePreset: preset
                                    });
                                  }
                                }
                              }}
                              className={`px-3 py-1.5 rounded-lg text-sm font-semibold transition-colors ${
                                editingDrinkDetail.editDateTimePreset === preset
                                  ? 'bg-purple-500 text-white'
                                  : 'bg-white/10 hover:bg-white/20 text-slate-300'
                              }`}
                            >
                              {preset === 'now' ? 'Now' : preset === 'yesterday' ? 'Yesterday' : preset === 'lastNight' ? 'Last Night' : 'Custom'}
                            </button>
                          ))}
                        </div>
                        {editingDrinkDetail.editDateTimePreset === 'custom' && (
                          <div className="flex gap-2">
                            <input
                              type="date"
                              value={editingDrinkDetail.editDate}
                              onChange={(e) => setEditingDrinkDetail({ ...editingDrinkDetail, editDate: e.target.value })}
                              className="flex-1 bg-white/10 border border-white/20 rounded-lg px-3 py-2 text-white focus:outline-none focus:ring-2 focus:ring-purple-400"
                            />
                            <input
                              type="time"
                              value={editingDrinkDetail.editTime}
                              onChange={(e) => setEditingDrinkDetail({ ...editingDrinkDetail, editTime: e.target.value })}
                              className="flex-1 bg-white/10 border border-white/20 rounded-lg px-3 py-2 text-white focus:outline-none focus:ring-2 focus:ring-purple-400"
                            />
                          </div>
                        )}
                      </div>

                      {/* Calories */}
                      <div>
                        <label className="text-xs text-slate-400 mb-2 block">Calories</label>
                        <input
                          type="number"
                          value={editingDrinkDetail.calories || ''}
                          onChange={(e) => setEditingDrinkDetail({ ...editingDrinkDetail, calories: e.target.value ? parseInt(e.target.value) : null })}
                          placeholder="Enter calories"
                          className="w-full bg-white/10 border border-white/20 rounded-lg px-4 py-2 text-white placeholder-slate-400 focus:outline-none focus:ring-2 focus:ring-purple-400"
                        />
                      </div>

                      {/* Cost */}
                      <div>
                        <label className="text-xs text-slate-400 mb-2 block">Cost</label>
                        <div className="relative">
                          <span className="absolute left-3 top-1/2 transform -translate-y-1/2 text-slate-400">$</span>
                          <input
                            type="number"
                            step="0.01"
                            value={editingDrinkDetail.cost || ''}
                            onChange={(e) => setEditingDrinkDetail({ ...editingDrinkDetail, cost: e.target.value ? parseFloat(e.target.value) : null })}
                            placeholder="0.00"
                            className="w-full bg-white/10 border border-white/20 rounded-lg pl-8 pr-4 py-2 text-white placeholder-slate-400 focus:outline-none focus:ring-2 focus:ring-purple-400"
                          />
                        </div>
                      </div>
                    </div>

                    {/* Action Buttons */}
                    <div className="flex gap-3 pt-4 border-t border-white/10">
                      <button
                        onClick={async () => {
                          try {
                            const timestamp = parseDateTimeInput(editingDrinkDetail.editDate, editingDrinkDetail.editTime);
                            await updateDrink(selectedDrink.id, {
                              timestamp: timestamp || selectedDrink.timestamp,
                              calories: editingDrinkDetail.calories,
                              cost: editingDrinkDetail.cost
                            });
                            setShowDrinkDetail(false);
                            setSelectedDrink(null);
                            setEditingDrinkDetail(null);
                          } catch (error) {
                            console.error('Error saving drink:', error);
                          }
                        }}
                        className="flex-1 bg-purple-500 hover:bg-purple-600 rounded-lg py-2 font-semibold transition-colors"
                      >
                        Save
                      </button>
                      <button
                        onClick={() => {
                          setShowDrinkDetail(false);
                          setSelectedDrink(null);
                          setEditingDrinkDetail(null);
                        }}
                        className="px-6 bg-white/10 hover:bg-white/20 rounded-lg py-2 transition-colors"
                      >
                        Cancel
                      </button>
                      <button
                        onClick={async () => {
                          if (confirm('Are you sure you want to delete this drink?')) {
                            await deleteDrink(selectedDrink.id);
                            setShowDrinkDetail(false);
                            setSelectedDrink(null);
                            setEditingDrinkDetail(null);
                          }
                        }}
                        className="px-4 bg-red-500/20 hover:bg-red-500/30 text-red-400 rounded-lg py-2 transition-colors"
                      >
                        Delete
                      </button>
                    </div>
                  </div>
                </div>
              </div>
            )}

            {/* Fixed "+ Log a Drink" Button */}
            {!showOtherForm && (
              <button
                onClick={() => {
                  setShowOtherForm(true);
                  setFreeformText('');
                  setParsedDrinks([]);
                  setFreeformDateTime(null);
                  setShowFreeformDateTime(false);
                }}
                className="fixed bottom-6 right-6 sm:bottom-8 sm:right-8 bg-purple-500 hover:bg-purple-600 text-white rounded-full p-4 sm:p-5 shadow-2xl z-40 transition-all hover:scale-110 active:scale-95 flex items-center justify-center gap-2 font-semibold text-base sm:text-lg"
                style={{ boxShadow: '0 10px 25px rgba(168, 85, 247, 0.4)' }}
              >
                <svg className="w-6 h-6 sm:w-7 sm:h-7" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2.5} d="M12 4v16m8-8H4" />
                </svg>
                <span className="hidden sm:inline">Log a Drink</span>
              </button>
            )}

            {/* Freeform Drink Entry Modal - shown when fixed button is clicked */}
            {showOtherForm && (
              <div className="fixed inset-0 bg-black/50 backdrop-blur-sm flex items-center justify-center z-50 p-4">
                <div className="bg-slate-800 rounded-2xl p-6 max-w-2xl w-full max-h-[90vh] overflow-y-auto">
                  <div className="flex items-center justify-between mb-4">
                    <h3 className="text-xl font-semibold text-white">Log Drinks</h3>
                    <button
                      onClick={() => {
                        setShowOtherForm(false);
                        setFreeformText('');
                        setParsedDrinks([]);
                      }}
                      className="text-slate-400 hover:text-white transition-colors"
                    >
                      <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                      </svg>
                    </button>
                  </div>
                  <div className="space-y-4">
                    <div>
                      <textarea
                        placeholder="Enter drinks naturally, e.g., '2 beers, 1 wine, 3 cocktails' or '1 negroni last night' or '2 guinness yesterday'"
                        value={freeformText}
                        onChange={(e) => setFreeformText(e.target.value)}
                        className="w-full bg-white/10 border border-white/20 rounded-lg px-4 py-3 text-white placeholder-slate-400 outline-none focus:ring-2 focus:ring-purple-400 min-h-[120px] resize-y"
                        autoFocus
                      />
                      <p className="text-xs text-slate-400 mt-2">
                        Type multiple drinks separated by commas or "and". Include date/time like "last night", "yesterday", "2 days ago", or "last Friday" to set when drinks were consumed.
                      </p>
                    </div>

                    {/* Date/Time Selection */}
                    <div className="border-t border-white/10 pt-4">
                      <button
                        onClick={() => setShowFreeformDateTime(!showFreeformDateTime)}
                        className="flex items-center justify-between w-full text-sm text-slate-300 hover:text-white transition-colors"
                      >
                        <span>Set Date/Time (optional)</span>
                        <svg 
                          className={`w-4 h-4 transition-transform ${showFreeformDateTime ? 'rotate-180' : ''}`}
                          fill="none" 
                          stroke="currentColor" 
                          viewBox="0 0 24 24"
                        >
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" />
                        </svg>
                      </button>
                      {showFreeformDateTime && (
                        <div className="mt-3 space-y-3">
                          <div className="flex flex-wrap gap-2">
                            {['now', 'yesterday', 'lastNight', 'custom'].map(preset => (
                              <button
                                key={preset}
                                onClick={() => {
                                  if (preset === 'custom') {
                                    setFreeformDateTime({ preset: 'custom', date: '', time: '' });
                                  } else {
                                    const presetDateTime = applyDateTimePreset(preset);
                                    if (presetDateTime) {
                                      const date = new Date(presetDateTime);
                                      setFreeformDateTime({
                                        preset: preset,
                                        date: date.toISOString().split('T')[0],
                                        time: date.toTimeString().slice(0, 5)
                                      });
                                    }
                                  }
                                }}
                                className={`px-3 py-1.5 rounded-lg text-sm font-semibold transition-colors ${
                                  freeformDateTime?.preset === preset
                                    ? 'bg-purple-500 text-white'
                                    : 'bg-white/10 hover:bg-white/20 text-slate-300'
                                }`}
                              >
                                {preset === 'now' ? 'Now' : preset === 'yesterday' ? 'Yesterday' : preset === 'lastNight' ? 'Last Night' : 'Custom'}
                              </button>
                            ))}
                          </div>
                          {freeformDateTime?.preset === 'custom' && (
                            <div className="flex gap-2">
                              <input
                                type="date"
                                value={freeformDateTime.date || ''}
                                onChange={(e) => setFreeformDateTime({ ...freeformDateTime, date: e.target.value })}
                                className="flex-1 bg-white/10 border border-white/20 rounded-lg px-3 py-2 text-white focus:outline-none focus:ring-2 focus:ring-purple-400"
                              />
                              <input
                                type="time"
                                value={freeformDateTime.time || ''}
                                onChange={(e) => setFreeformDateTime({ ...freeformDateTime, time: e.target.value })}
                                className="flex-1 bg-white/10 border border-white/20 rounded-lg px-3 py-2 text-white focus:outline-none focus:ring-2 focus:ring-purple-400"
                              />
                            </div>
                          )}
                          {freeformDateTime && freeformDateTime.preset !== 'custom' && (
                            <div className="text-xs text-slate-400">
                              {freeformDateTime.preset === 'now' 
                                ? 'Drinks will be logged with current date/time'
                                : freeformDateTime.preset === 'yesterday'
                                ? 'Drinks will be logged for yesterday'
                                : 'Drinks will be logged for last night (11 PM)'}
                            </div>
                          )}
                        </div>
                      )}
                    </div>

                    {/* Parsed Drinks Preview */}
                    {parsedDrinks.length > 0 && (
                      <div className="space-y-3">
                        <div className="text-sm font-semibold text-slate-300">
                          Preview ({parsedDrinks.length} drink{parsedDrinks.length !== 1 ? 's' : ''}):
                        </div>
                        <div className="space-y-2 max-h-[300px] overflow-y-auto">
                          {parsedDrinks.map((drink, index) => (
                            <div key={index} className="bg-white/5 rounded-lg p-3 flex items-start gap-3">
                              <div className="flex-1">
                                <div className="flex items-center gap-2 mb-2">
                                  <input
                                    type="text"
                                    value={drink.name}
                                    onChange={(e) => updateParsedDrink(index, 'name', e.target.value)}
                                    className="flex-1 bg-white/10 border border-white/20 rounded px-3 py-1.5 text-white text-sm focus:outline-none focus:ring-2 focus:ring-purple-400"
                                  />
                                  <select
                                    value={drink.category}
                                    onChange={(e) => updateParsedDrink(index, 'category', e.target.value)}
                                    className="bg-white/10 border border-white/20 rounded px-3 py-1.5 text-white text-sm focus:outline-none focus:ring-2 focus:ring-purple-400"
                                  >
                                    <option value="Beer">Beer</option>
                                    <option value="Wine">Wine</option>
                                    <option value="Cocktail">Cocktail</option>
                                  </select>
                                </div>
                                <div className="flex items-center gap-2 text-xs text-slate-400 flex-wrap">
                                  {drink.matched === false && (
                                    <span className="text-yellow-400">⚠ Not recognized - please verify</span>
                                  )}
                                  {drink.calories && (
                                    <span>Calories: {drink.calories}</span>
                                  )}
                                  {drink.cost && (
                                    <span>Cost: ${drink.cost}</span>
                                  )}
                                  {drink.timestamp && (
                                    <span className="text-purple-400">
                                      📅 {formatDateTimeForDisplay(drink.timestamp)}
                                    </span>
                                  )}
                                </div>
                              </div>
                              <button
                                onClick={() => removeParsedDrink(index)}
                                className="text-red-400 hover:text-red-300 transition-colors"
                              >
                                <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                                </svg>
                              </button>
                            </div>
                          ))}
                        </div>
                        <button
                          onClick={() => batchLogDrinks(parsedDrinks)}
                          className="w-full bg-purple-500 hover:bg-purple-600 text-white rounded-lg py-3 font-semibold transition-colors"
                        >
                          Log {parsedDrinks.length} Drink{parsedDrinks.length !== 1 ? 's' : ''}
                        </button>
                      </div>
                    )}

                    {parsedDrinks.length === 0 && freeformText.trim() && (
                      <div className="text-sm text-slate-400 text-center py-4">
                        Start typing to see parsed drinks...
                      </div>
                    )}

                    <button
                      onClick={() => {
                        setShowOtherForm(false);
                        setFreeformText('');
                        setParsedDrinks([]);
                      }}
                      className="w-full bg-white/20 hover:bg-white/30 rounded-lg py-2 transition-colors"
                    >
                      Cancel
                    </button>
                  </div>
                </div>
              </div>
            )}

            {/* Footer */}
            <footer className="mt-12 pt-8 pb-6 border-t border-white/10">
              <div className="flex flex-col sm:flex-row items-center justify-between gap-4 text-sm text-slate-400">
                <div className="flex items-center gap-2">
                  <span>© {new Date().getFullYear()} Drink Tracker</span>
                  <span className="hidden sm:inline">•</span>
                  <span className="text-purple-400 font-semibold">v{APP_VERSION}</span>
                </div>
                <div className="text-xs text-slate-500">
                  Track every drink, understand your habits
                </div>
              </div>
            </footer>
          </div>
        </div>
      );
    }

    ReactDOM.render(<DrinkTracker />, document.getElementById('root'));
  </script>
</body>
</html>
