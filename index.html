<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>2026 Drink Tracker</title>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
  <div id="root"></div>

  <script>
    // This runs BEFORE Babel - test if JavaScript is working
    console.log('=== PRE-BABEL TEST: JavaScript is working ===');
    alert('JavaScript is working! Check console for debug messages.');
    window.addEventListener('error', function(e) {
      console.error('=== JAVASCRIPT ERROR ===', e.error, e.message, e.filename, e.lineno);
      alert('JavaScript Error: ' + e.message + ' at ' + e.filename + ':' + e.lineno);
    });
    window.addEventListener('unhandledrejection', function(e) {
      console.error('=== UNHANDLED PROMISE REJECTION ===', e.reason);
      alert('Unhandled Promise Rejection: ' + e.reason);
    });
  </script>

  <script type="text/babel">
    console.log('[DEBUG] Script starting...');
    
    const { useState, useEffect } = React;

    // Supabase configuration
    const SUPABASE_URL = 'https://jftfalkxfsasptpoqztd.supabase.co';
    const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImpmdGZhbGt4ZnNhc3B0cG9xenRkIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjY3Njk0OTMsImV4cCI6MjA4MjM0NTQ5M30.zOMezm88s6GMvxVuyT1M0MK_kJKYOsIVg7m614jl_XI';
    
    console.log('[DEBUG] Creating Supabase client...');
    const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY, {
      auth: {
        persistSession: true,
        autoRefreshToken: true,
        detectSessionInUrl: true,
        storage: window.localStorage, // Explicitly use localStorage
        storageKey: 'sb-jftfalkxfsasptpoqztd-auth-token' // Explicit storage key
      }
    });
    console.log('[DEBUG] Supabase client created with explicit localStorage');
    
    // Immediately check what's in localStorage
    console.log('[DEBUG] Checking localStorage immediately after client creation...');
    const supabaseKey = 'sb-jftfalkxfsasptpoqztd-auth-token';
    const immediateCheck = localStorage.getItem(supabaseKey);
    console.log('[DEBUG] Immediate localStorage check:', {
      key: supabaseKey,
      exists: !!immediateCheck,
      value: immediateCheck ? 'present' : 'missing'
    });

    function DrinkTracker() {
      const [user, setUser] = useState(null);
      const [session, setSession] = useState(null);
      const [authLoading, setAuthLoading] = useState(true);
      const [drinks, setDrinks] = useState([]);
      const [loading, setLoading] = useState(true);
      const [showOtherForm, setShowOtherForm] = useState(false);
      const [customDrink, setCustomDrink] = useState('');
      const [quickLogDrinks, setQuickLogDrinks] = useState([
        { name: 'Martini', category: 'Cocktail' },
        { name: 'Gin & Tonic', category: 'Cocktail' },
        { name: 'Guinness', category: 'Beer' },
        { name: 'Narragansett', category: 'Beer' },
        { name: 'White Wine', category: 'Wine' },
        { name: 'Red Wine', category: 'Wine' }
      ]);
      const [dismissedSuggestions, setDismissedSuggestions] = useState([]);
      const [editMode, setEditMode] = useState(false);
      const [editingDrink, setEditingDrink] = useState(null);
      const [editName, setEditName] = useState('');
      const [editCategory, setEditCategory] = useState('');
      
      // Pagination state
      const [currentPage, setCurrentPage] = useState(1);
      const itemsPerPage = 10;
      
      // Auth form state
      const [showLogin, setShowLogin] = useState(false);
      const [showSignup, setShowSignup] = useState(false);
      const [email, setEmail] = useState('');
      const [password, setPassword] = useState('');
      const [authError, setAuthError] = useState('');
      
      // Caching and offline state
      const [isOnline, setIsOnline] = useState(navigator.onLine);
      const [isSyncing, setIsSyncing] = useState(false);
      const [cacheTimestamp, setCacheTimestamp] = useState(null);
      const CACHE_VALIDITY_MS = 5 * 60 * 1000; // 5 minutes

      // Check for existing session on mount
      // Note: We rely on onAuthStateChange INITIAL_SESSION event, but also call checkSession as backup
      useEffect(() => {
        // Wait a moment for Supabase to initialize, then check session
        // The INITIAL_SESSION event should fire first, but we'll also check manually
        const timer = setTimeout(() => {
          console.log('[DEBUG] Component mounted, calling checkSession after delay');
          checkSession();
        }, 500); // Increased delay to give INITIAL_SESSION time to fire
        
        return () => clearTimeout(timer);
      }, []);

      // Offline/online detection
      useEffect(() => {
        const handleOnline = () => setIsOnline(true);
        const handleOffline = () => setIsOnline(false);
        
        window.addEventListener('online', handleOnline);
        window.addEventListener('offline', handleOffline);
        
        return () => {
          window.removeEventListener('online', handleOnline);
          window.removeEventListener('offline', handleOffline);
        };
      }, []);

      // Sync when coming back online
      useEffect(() => {
        if (isOnline && user) {
          syncWhenOnline();
        }
      }, [isOnline, user?.id]);

      // Load data when user is available
      useEffect(() => {
        if (user) {
          loadData();
        }
      }, [user]);

      const validateSession = async (session) => {
        // #region agent log
        console.log('[DEBUG] validateSession called:', {
          hasSession: !!session,
          hasUser: !!session?.user,
          userId: session?.user?.id,
          expiresAt: session?.expires_at,
          accessToken: session?.access_token ? 'exists' : 'missing'
        });
        // #endregion
        
        if (!session) {
          // #region agent log
          console.log('[DEBUG] validateSession: No session provided');
          // #endregion
          return false;
        }
        
        try {
          // Check if token is expired
          const expiresAt = session.expires_at;
          if (expiresAt) {
            const now = Math.floor(Date.now() / 1000);
            const timeUntilExpiry = expiresAt - now;
            
            // #region agent log
            console.log('[DEBUG] Token expiry check:', {
              expiresAt,
              now,
              timeUntilExpiry,
              isExpired: expiresAt < now,
              minutesUntilExpiry: Math.floor(timeUntilExpiry / 60)
            });
            // #endregion
            
            if (expiresAt < now) {
              // Token expired, try to refresh
              // #region agent log
              console.log('[DEBUG] Token expired, attempting refresh');
              // #endregion
              const { data: { session: refreshedSession }, error } = await supabase.auth.refreshSession();
              if (error || !refreshedSession) {
                // #region agent log
                console.error('[DEBUG] Refresh failed:', { error: error?.message, hasRefreshedSession: !!refreshedSession });
                // #endregion
                return false;
              }
              // #region agent log
              console.log('[DEBUG] Token refreshed successfully');
              // #endregion
              return refreshedSession;
            }
          }
          // #region agent log
          console.log('[DEBUG] Session is valid');
          // #endregion
          return session;
        } catch (error) {
          // #region agent log
          console.error('[DEBUG] Error validating session:', error);
          // #endregion
          return false;
        }
      };

      const checkSession = async () => {
        console.log('[DEBUG] ===== checkSession START =====');
        
        // First, check what's in localStorage
        const supabaseKey = 'sb-jftfalkxfsasptpoqztd-auth-token';
        const stored = localStorage.getItem(supabaseKey);
        console.log('[DEBUG] localStorage check:', {
          key: supabaseKey,
          exists: !!stored,
          length: stored ? stored.length : 0
        });
        
        let parsedSession = null;
        if (stored) {
          try {
            const parsed = JSON.parse(stored);
            console.log('[DEBUG] Parsed localStorage:', {
              hasCurrentSession: !!parsed?.currentSession,
              hasUser: !!parsed?.currentSession?.user,
              userEmail: parsed?.currentSession?.user?.email,
              expiresAt: parsed?.currentSession?.expires_at,
              accessToken: parsed?.currentSession?.access_token ? 'exists' : 'missing'
            });
            parsedSession = parsed?.currentSession;
          } catch (e) {
            console.error('[DEBUG] Error parsing localStorage:', e);
          }
        } else {
          console.log('[DEBUG] ⚠️ No localStorage data found!');
        }
        
        try {
          // Simply get the session - Supabase handles persistence automatically
          console.log('[DEBUG] Calling supabase.auth.getSession()...');
          const { data: { session }, error } = await supabase.auth.getSession();
          
          console.log('[DEBUG] getSession result:', {
            hasError: !!error,
            errorMessage: error?.message,
            errorCode: error?.code,
            hasSession: !!session,
            hasUser: !!session?.user,
            userEmail: session?.user?.email,
            expiresAt: session?.expires_at,
            accessToken: session?.access_token ? 'exists' : 'missing'
          });
          
          if (error) {
            console.error('[DEBUG] ✗ Error getting session:', error);
            setSession(null);
            setUser(null);
            setAuthLoading(false);
            return;
          }
          
          // If we have a session, restore it
          if (session && session.user) {
            console.log('[DEBUG] ✓ Session found! Restoring user:', session.user.email);
            console.log('[DEBUG] Setting session and user state...');
            setSession(session);
            setUser(session.user);
            console.log('[DEBUG] State set - session:', !!session, 'user:', session.user.email);
            
            // Load cached data immediately if available
            loadCachedDrinks(session.user.id);
          } else if (parsedSession && parsedSession.user) {
            // Fallback: If getSession() returns null but we have data in localStorage, try to restore manually
            console.log('[DEBUG] ⚠️ getSession() returned null but localStorage has session data');
            console.log('[DEBUG] Attempting manual session restoration...');
            console.log('[DEBUG] Parsed session data:', {
              hasUser: !!parsedSession.user,
              userEmail: parsedSession.user.email,
              userId: parsedSession.user.id,
              expiresAt: parsedSession.expires_at,
              hasAccessToken: !!parsedSession.access_token
            });
            
            // Check if token is expired
            const expiresAt = parsedSession.expires_at;
            if (expiresAt) {
              const now = Math.floor(Date.now() / 1000);
              const timeUntilExpiry = expiresAt - now;
              console.log('[DEBUG] Token expiry check:', {
                expiresAt,
                now,
                timeUntilExpiry,
                isExpired: expiresAt < now,
                minutesUntilExpiry: Math.floor(timeUntilExpiry / 60)
              });
              
              if (expiresAt < now) {
                console.log('[DEBUG] ✗ Token in localStorage is expired, cannot restore');
                // Try to refresh the session
                console.log('[DEBUG] Attempting to refresh expired session...');
                try {
                  const { data: { session: refreshedSession }, error: refreshError } = await supabase.auth.refreshSession();
                  if (refreshError || !refreshedSession) {
                    console.error('[DEBUG] ✗ Refresh failed:', refreshError?.message);
                    setSession(null);
                    setUser(null);
                    setAuthLoading(false);
                    return;
                  }
                  console.log('[DEBUG] ✓ Session refreshed successfully');
                  setSession(refreshedSession);
                  setUser(refreshedSession.user);
                  loadCachedDrinks(refreshedSession.user.id);
                  setAuthLoading(false);
                  return;
                } catch (refreshErr) {
                  console.error('[DEBUG] ✗ Exception during refresh:', refreshErr);
                  setSession(null);
                  setUser(null);
                  setAuthLoading(false);
                  return;
                }
              }
            }
            
            // Try to set the session manually
            console.log('[DEBUG] ✓ Token is valid, setting session from localStorage data');
            setSession(parsedSession);
            setUser(parsedSession.user);
            console.log('[DEBUG] ✓ Manual restoration complete - user:', parsedSession.user.email);
            console.log('[DEBUG] State should now be set - verifying...');
            
            // Verify state was set (check in next render)
            setTimeout(() => {
              console.log('[DEBUG] State verification - session:', !!session, 'user:', user?.email);
            }, 100);
            
            // Load cached data
            loadCachedDrinks(parsedSession.user.id);
          } else {
            console.log('[DEBUG] ✗ No session found in getSession() response');
            console.log('[DEBUG] ✗ No valid session in localStorage either');
            setSession(null);
            setUser(null);
          }
        } catch (error) {
          console.error('[DEBUG] ✗ Exception in checkSession:', error);
          console.error('[DEBUG] Exception details:', error.message, error.stack);
          setSession(null);
          setUser(null);
        } finally {
          setAuthLoading(false);
          console.log('[DEBUG] ===== checkSession END =====');
        }
      };

      const handleSignUp = async (e) => {
        e.preventDefault();
        setAuthError('');
        
        try {
          const { data, error } = await supabase.auth.signUp({
            email: email,
            password: password,
            options: {
              emailRedirectTo: `${window.location.origin}${window.location.pathname}`
            }
          });

          if (error) throw error;

          if (data.user) {
            // If session exists, user is immediately signed in (email confirmation disabled)
            // If no session, user needs to confirm email first
            if (data.session) {
              setUser(data.user);
              setSession(data.session);
              setShowSignup(false);
              setEmail('');
              setPassword('');
            } else {
              // Email confirmation required
              setShowSignup(false);
              setEmail('');
              setPassword('');
              alert('Account created! Please check your email to confirm your account before signing in.');
            }
          }
        } catch (error) {
          setAuthError(error.message);
          console.error('Error signing up:', error);
        }
      };

      const handleSignIn = async (e) => {
        e.preventDefault();
        setAuthError('');
        
        try {
          console.log('[DEBUG] Attempting to sign in...');
          const { data, error } = await supabase.auth.signInWithPassword({
            email: email,
            password: password,
          });

          if (error) {
            console.error('[DEBUG] Sign in error:', error);
            throw error;
          }

          console.log('[DEBUG] Sign in successful:', {
            hasUser: !!data.user,
            hasSession: !!data.session,
            userEmail: data.user?.email
          });

          if (data.user && data.session) {
            // Verify session is being saved
            const { data: { session: verifySession } } = await supabase.auth.getSession();
            console.log('[DEBUG] Session verification after sign in:', {
              hasSession: !!verifySession,
              userEmail: verifySession?.user?.email
            });
            
            // Check localStorage
            const supabaseKey = 'sb-jftfalkxfsasptpoqztd-auth-token';
            const stored = localStorage.getItem(supabaseKey);
            console.log('[DEBUG] localStorage after sign in:', {
              key: supabaseKey,
              exists: !!stored
            });
            
            setUser(data.user);
            setSession(data.session);
            setShowLogin(false);
            setEmail('');
            setPassword('');
          } else {
            console.error('[DEBUG] Sign in succeeded but no session!');
            setAuthError('Sign in succeeded but session was not created. Please try again.');
          }
        } catch (error) {
          setAuthError(error.message);
          console.error('[DEBUG] Error signing in:', error);
        }
      };

      const handleSignOut = async () => {
        try {
          // Clear cached data before signing out
          if (user) {
            const userId = user.id;
            localStorage.removeItem(`drinks-cache-2026-${userId}`);
            localStorage.removeItem(`drinks-cache-timestamp-2026-${userId}`);
            localStorage.removeItem(`quicklog-2026-${userId}`);
            localStorage.removeItem(`dismissed-suggestions-2026-${userId}`);
          }
          
          const { error } = await supabase.auth.signOut();
          if (error) throw error;
          
          setUser(null);
          setSession(null);
          setDrinks([]);
          setCacheTimestamp(null);
          setQuickLogDrinks([
            { name: 'Martini', category: 'Cocktail' },
            { name: 'Gin & Tonic', category: 'Cocktail' },
            { name: 'Guinness', category: 'Beer' },
            { name: 'Narragansett', category: 'Beer' },
            { name: 'White Wine', category: 'Wine' },
            { name: 'Red Wine', category: 'Wine' }
          ]);
          setDismissedSuggestions([]);
        } catch (error) {
          console.error('Error signing out:', error);
        }
      };

      // Listen for auth changes (including email confirmation)
      // This MUST be set up before checkSession runs
      useEffect(() => {
        console.log('[DEBUG] Setting up auth state change listener (should run FIRST)');
        
        const { data: { subscription } } = supabase.auth.onAuthStateChange((event, session) => {
          console.log('[DEBUG] ===== Auth state changed =====');
          console.log('[DEBUG] Event:', event);
          console.log('[DEBUG] Session:', {
            hasSession: !!session,
            hasUser: !!session?.user,
            userEmail: session?.user?.email || 'no user',
            expiresAt: session?.expires_at,
            accessToken: session?.access_token ? 'exists' : 'missing'
          });
          
          // Handle different auth events
          if (event === 'SIGNED_IN' && session) {
            console.log('[DEBUG] ✓ SIGNED_IN event - setting user');
            setSession(session);
            setUser(session.user);
          } else if (event === 'TOKEN_REFRESHED' && session) {
            console.log('[DEBUG] ✓ TOKEN_REFRESHED event - updating session');
            setSession(session);
            setUser(session.user);
          } else if (event === 'SIGNED_OUT') {
            console.log('[DEBUG] ✗ SIGNED_OUT event');
            // Clear all cached data on sign out
            if (user) {
              const userId = user.id;
              localStorage.removeItem(`drinks-cache-2026-${userId}`);
              localStorage.removeItem(`drinks-cache-timestamp-2026-${userId}`);
            }
            setSession(null);
            setUser(null);
            setDrinks([]);
            setCacheTimestamp(null);
          } else if (event === 'INITIAL_SESSION') {
            // This fires when Supabase restores a session from storage
            // This is the PRIMARY way sessions are restored
            console.log('[DEBUG] ===== INITIAL_SESSION EVENT (PRIMARY RESTORE) =====');
            if (session && session.user) {
              console.log('[DEBUG] ✓✓✓ INITIAL_SESSION - session found! Restoring:', session.user.email);
              setSession(session);
              setUser(session.user);
              setAuthLoading(false); // Session restored, we're done loading
              
              // Load cached data
              loadCachedDrinks(session.user.id);
            } else {
              console.log('[DEBUG] ✗ INITIAL_SESSION - no session found');
              // Only clear if we don't have a user (might have been manually restored)
              const currentUser = user; // Capture current user before state update
              if (!currentUser) {
                console.log('[DEBUG] No existing user, clearing state');
                setSession(null);
                setUser(null);
              } else {
                console.log('[DEBUG] User already exists from manual restore, keeping state');
              }
              setAuthLoading(false);
            }
          } else {
            console.log('[DEBUG] Other auth event:', event);
            // For other events, update state if we have a session
            if (session) {
              setSession(session);
              setUser(session.user);
            }
          }
          console.log('[DEBUG] ===== Auth state change handler complete =====');
        });

        return () => {
          console.log('[DEBUG] Cleaning up auth state change listener');
          subscription.unsubscribe();
        };
      }, []);

      const cacheDrinksData = (drinksData, userId) => {
        if (!userId) return;
        try {
          const cacheKey = `drinks-cache-2026-${userId}`;
          const timestampKey = `drinks-cache-timestamp-2026-${userId}`;
          localStorage.setItem(cacheKey, JSON.stringify(drinksData));
          localStorage.setItem(timestampKey, Date.now().toString());
          setCacheTimestamp(Date.now());
        } catch (error) {
          console.error('Error caching drinks data:', error);
        }
      };

      const loadCachedDrinks = (userId) => {
        if (!userId) return null;
        try {
          const cacheKey = `drinks-cache-2026-${userId}`;
          const timestampKey = `drinks-cache-timestamp-2026-${userId}`;
          const cached = localStorage.getItem(cacheKey);
          const timestamp = localStorage.getItem(timestampKey);
          
          if (cached && timestamp) {
            const cacheAge = Date.now() - parseInt(timestamp);
            const cachedData = JSON.parse(cached);
            
            // Return cached data if it's still valid
            if (cacheAge < CACHE_VALIDITY_MS) {
              setDrinks(cachedData);
              setCacheTimestamp(parseInt(timestamp));
              return cachedData;
            }
          }
        } catch (error) {
          console.error('Error loading cached drinks:', error);
        }
        return null;
      };

      const checkOnlineStatus = () => {
        return navigator.onLine;
      };

      const syncWhenOnline = async () => {
        if (!isOnline || isSyncing) return;
        
        setIsSyncing(true);
        try {
          // Get current session to ensure we're authenticated
          const { data: { session: currentSession } } = await supabase.auth.getSession();
          if (!currentSession || !currentSession.user) {
            setIsSyncing(false);
            return;
          }
          
          // Reload fresh data from server
          const { data: drinksData, error } = await supabase
            .from('drinks')
            .select('*')
            .eq('user_id', currentSession.user.id)
            .order('timestamp', { ascending: false });

          if (error) throw error;
          
          if (drinksData) {
            setDrinks(drinksData);
            cacheDrinksData(drinksData, currentSession.user.id);
          }
        } catch (error) {
          console.error('Error syncing data:', error);
        } finally {
          setIsSyncing(false);
        }
      };

      const loadData = async () => {
        if (!user) {
          setLoading(false);
          return;
        }

        // First, try to load cached data for instant display
        const cachedData = loadCachedDrinks(user.id);
        if (cachedData && cachedData.length > 0) {
          setLoading(false); // Show cached data immediately
        }

        try {
          // Then fetch fresh data from Supabase
          const { data: drinksData, error } = await supabase
            .from('drinks')
            .select('*')
            .eq('user_id', user.id)
            .order('timestamp', { ascending: false });

          if (error) {
            // If offline or network error, use cached data
            if (!isOnline || error.message.includes('fetch')) {
              console.warn('Network error, using cached data');
              if (!cachedData || cachedData.length === 0) {
                setLoading(false);
              }
              return;
            }
            throw error;
          }
          
          if (drinksData) {
            setDrinks(drinksData);
            cacheDrinksData(drinksData, user.id);
          }

          // Load quick log and dismissed from localStorage (user-specific)
          const userKey = `quicklog-2026-${user.id}`;
          const storedQuickLog = localStorage.getItem(userKey);
          if (storedQuickLog) {
            setQuickLogDrinks(JSON.parse(storedQuickLog));
          }

          const dismissedKey = `dismissed-suggestions-2026-${user.id}`;
          const storedDismissed = localStorage.getItem(dismissedKey);
          if (storedDismissed) {
            setDismissedSuggestions(JSON.parse(storedDismissed));
          }
        } catch (error) {
          console.error('Error loading data:', error);
          // Show error to user if it's a critical issue
          if (error.message && (error.message.includes('column') || error.message.includes('permission'))) {
            alert(`Database error: ${error.message}\n\nPlease check your Supabase setup. See SUPABASE_SETUP.md for instructions.`);
          }
        } finally {
          setLoading(false);
        }
      };

      const saveQuickLog = (newQuickLog) => {
        if (!user) return;
        const userKey = `quicklog-2026-${user.id}`;
        localStorage.setItem(userKey, JSON.stringify(newQuickLog));
      };

      const saveDismissed = (newDismissed) => {
        if (!user) return;
        const dismissedKey = `dismissed-suggestions-2026-${user.id}`;
        localStorage.setItem(dismissedKey, JSON.stringify(newDismissed));
      };

      const normalizeDrinkName = (name) => {
        return name.toLowerCase().trim();
      };

      const quickAddDrink = async (name, category) => {
        if (!user) return;
        
        try {
          // Get current session to ensure we use the authenticated user ID
          const { data: { session: currentSession } } = await supabase.auth.getSession();
          
          if (!currentSession || !currentSession.access_token) {
            throw new Error('No valid session found. Please sign in again.');
          }
          
          const newDrink = {
            name: name,
            category: category,
            timestamp: new Date().toISOString(),
            user_id: currentSession.user.id
          };

          const { data, error } = await supabase
            .from('drinks')
            .insert([newDrink])
            .select();

          if (error) throw error;

          if (data) {
            const updatedDrinks = [data[0], ...drinks];
            setDrinks(updatedDrinks);
            // Update cache
            cacheDrinksData(updatedDrinks, currentSession.user.id);
          }
        } catch (error) {
          console.error('Error adding drink:', error);
          const errorMessage = error.message || 'Unknown error occurred';
          
          // If offline, queue the action
          if (!isOnline || error.message.includes('fetch')) {
            alert('You are offline. The drink will be saved when you reconnect.');
            // Could implement offline queue here
            return;
          }
          
          alert(`Failed to add drink: ${errorMessage}\n\nCheck the browser console (F12) for more details.\n\nIf you see "column" or "permission" errors, you may need to set up your Supabase database. See SUPABASE_SETUP.md for instructions.`);
        }
      };

      const addCustomDrink = async (category) => {
        if (!customDrink.trim() || !user) return;
        
        try {
          // Get current session to ensure we use the authenticated user ID
          const { data: { session: currentSession } } = await supabase.auth.getSession();
          
          if (!currentSession || !currentSession.access_token) {
            throw new Error('No valid session found. Please sign in again.');
          }
          
          const newDrink = {
            name: customDrink.trim(),
            category: category,
            timestamp: new Date().toISOString(),
            user_id: currentSession.user.id
          };

          const { data, error } = await supabase
            .from('drinks')
            .insert([newDrink])
            .select();

          if (error) throw error;

          if (data) {
            const updatedDrinks = [data[0], ...drinks];
            setDrinks(updatedDrinks);
            // Update cache
            cacheDrinksData(updatedDrinks, currentSession.user.id);
          }
          
          setCustomDrink('');
          setShowOtherForm(false);
        } catch (error) {
          console.error('Error adding drink:', error);
          const errorMessage = error.message || 'Unknown error occurred';
          
          // If offline, queue the action
          if (!isOnline || error.message.includes('fetch')) {
            alert('You are offline. The drink will be saved when you reconnect.');
            return;
          }
          
          alert(`Failed to add drink: ${errorMessage}\n\nCheck the browser console (F12) for more details.\n\nIf you see "column" or "permission" errors, you may need to set up your Supabase database. See SUPABASE_SETUP.md for instructions.`);
        }
      };

      const deleteDrink = async (id) => {
        if (!user) return;
        
        try {
          const { error } = await supabase
            .from('drinks')
            .delete()
            .eq('id', id)
            .eq('user_id', user.id); // Ensure user can only delete their own drinks

          if (error) throw error;

          const updatedDrinks = drinks.filter(d => d.id !== id);
          setDrinks(updatedDrinks);
          // Update cache
          cacheDrinksData(updatedDrinks, user.id);
        } catch (error) {
          console.error('Error deleting drink:', error);
          
          // If offline, show message
          if (!isOnline || error.message.includes('fetch')) {
            alert('You are offline. The deletion will be synced when you reconnect.');
            return;
          }
          
          alert('Failed to delete drink. Please try again.');
        }
      };

      const removeFromQuickLog = (drinkName) => {
        const updated = quickLogDrinks.filter(d => d.name !== drinkName);
        setQuickLogDrinks(updated);
        saveQuickLog(updated);
      };

      const updateQuickLogDrink = (oldName, newName, newCategory) => {
        if (!newName.trim() || !newCategory) return;
        
        // Check for duplicates (excluding the drink being edited)
        const normalizedNewName = normalizeDrinkName(newName);
        const isDuplicate = quickLogDrinks.some(d => 
          normalizeDrinkName(d.name) === normalizedNewName && d.name !== oldName
        );
        
        if (isDuplicate) {
          alert('A drink with this name already exists in Quick Log.');
          return;
        }
        
        const updated = quickLogDrinks.map(d => 
          d.name === oldName ? { name: newName.trim(), category: newCategory } : d
        );
        setQuickLogDrinks(updated);
        saveQuickLog(updated);
        setEditingDrink(null);
        setEditName('');
        setEditCategory('');
      };

      const createNewQuickLogDrink = () => {
        if (!editName.trim() || !editCategory) {
          alert('Please enter a drink name and select a category.');
          return;
        }
        
        // Check for duplicates
        const normalizedNewName = normalizeDrinkName(editName);
        const isDuplicate = quickLogDrinks.some(d => 
          normalizeDrinkName(d.name) === normalizedNewName
        );
        
        if (isDuplicate) {
          alert('A drink with this name already exists in Quick Log.');
          return;
        }
        
        const updated = [...quickLogDrinks, { name: editName.trim(), category: editCategory }];
        setQuickLogDrinks(updated);
        saveQuickLog(updated);
        setEditingDrink(null);
        setEditName('');
        setEditCategory('');
      };

      const startEditingDrink = (drink) => {
        setEditingDrink(drink.name);
        setEditName(drink.name);
        setEditCategory(drink.category);
      };

      const startCreatingNewDrink = () => {
        setEditingDrink('__NEW__');
        setEditName('');
        setEditCategory('');
      };

      const addToQuickLog = (drinkName, category) => {
        const updated = [...quickLogDrinks, { name: drinkName, category: category }];
        setQuickLogDrinks(updated);
        saveQuickLog(updated);
      };

      const dismissSuggestion = (drinkName) => {
        const updated = [...dismissedSuggestions, normalizeDrinkName(drinkName)];
        setDismissedSuggestions(updated);
        saveDismissed(updated);
      };

      const getSuggestion = () => {
        const drinkCounts = {};
        
        drinks.forEach(drink => {
          const normalized = normalizeDrinkName(drink.name);
          const isInQuickLog = quickLogDrinks.some(qd => normalizeDrinkName(qd.name) === normalized);
          const isDismissed = dismissedSuggestions.includes(normalized);
          
          if (!isInQuickLog && !isDismissed) {
            if (!drinkCounts[normalized]) {
              drinkCounts[normalized] = { count: 0, originalName: drink.name, category: drink.category };
            }
            drinkCounts[normalized].count++;
          }
        });

        for (const [normalized, data] of Object.entries(drinkCounts)) {
          if (data.count >= 3) {
            return { name: data.originalName, category: data.category, count: data.count };
          }
        }
        return null;
      };

      const suggestion = getSuggestion();

      const exportToCSV = () => {
        if (drinks.length === 0) {
          alert('No drinks to export yet!');
          return;
        }

        const headers = ['Name', 'Category', 'Date', 'Time', 'Timestamp'];
        const rows = drinks.map(drink => {
          const date = new Date(drink.timestamp);
          const dateStr = date.toLocaleDateString('en-US');
          const timeStr = date.toLocaleTimeString('en-US');
          return [
            drink.name,
            drink.category,
            dateStr,
            timeStr,
            drink.timestamp
          ];
        });

        const csvContent = [
          headers.join(','),
          ...rows.map(row => row.map(cell => `"${cell}"`).join(','))
        ].join('\n');

        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement('a');
        const url = URL.createObjectURL(blob);
        link.setAttribute('href', url);
        link.setAttribute('download', `drink-tracker-${new Date().toISOString().split('T')[0]}.csv`);
        link.style.visibility = 'hidden';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      };

      const formatDate = (timestamp) => {
        const date = new Date(timestamp);
        const today = new Date();
        const yesterday = new Date(today);
        yesterday.setDate(yesterday.getDate() - 1);

        if (date.toDateString() === today.toDateString()) {
          return 'Today';
        } else if (date.toDateString() === yesterday.toDateString()) {
          return 'Yesterday';
        } else {
          return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
        }
      };

      const formatTime = (timestamp) => {
        return new Date(timestamp).toLocaleTimeString('en-US', { 
          hour: 'numeric', 
          minute: '2-digit',
          hour12: true 
        });
      };

      const getStats = () => {
        const total = drinks.length;
        const beer = drinks.filter(d => d.category === 'Beer').length;
        const wine = drinks.filter(d => d.category === 'Wine').length;
        const cocktail = drinks.filter(d => d.category === 'Cocktail').length;
        return { total, beer, wine, cocktail };
      };

      const stats = getStats();

      // Pagination calculations
      const totalPages = Math.ceil(drinks.length / itemsPerPage);
      const startIndex = (currentPage - 1) * itemsPerPage;
      const endIndex = startIndex + itemsPerPage;
      const paginatedDrinks = drinks.slice(startIndex, endIndex);

      // Reset to last valid page when drinks change (e.g., after deletion)
      useEffect(() => {
        const newTotalPages = Math.ceil(drinks.length / itemsPerPage);
        if (currentPage > newTotalPages && newTotalPages > 0) {
          setCurrentPage(newTotalPages);
        }
      }, [drinks.length, itemsPerPage]);

      // Show loading while checking auth
      if (authLoading) {
        return (
          <div className="min-h-screen bg-gradient-to-br from-slate-900 via-purple-900 to-slate-900 text-white flex items-center justify-center">
            <div className="text-2xl">Loading...</div>
          </div>
        );
      }

      // Show auth UI if not logged in
      if (!user) {
        return (
          <div className="min-h-screen bg-gradient-to-br from-slate-900 via-purple-900 to-slate-900 text-white flex items-center justify-center p-6">
            <div className="max-w-md w-full">
              <div className="text-center mb-8">
                <h1 className="text-4xl font-bold mb-2">2026 Drink Tracker</h1>
                <p className="text-slate-300">Track every drink, understand your habits</p>
              </div>

              {!showLogin && !showSignup && (
                <div className="bg-white/10 backdrop-blur rounded-2xl p-8 space-y-4">
                  <button
                    onClick={() => {
                      setShowSignup(true);
                      setShowLogin(false);
                      setAuthError('');
                    }}
                    className="w-full bg-purple-500 hover:bg-purple-600 rounded-lg py-3 font-semibold transition-colors"
                  >
                    Sign Up
                  </button>
                  <button
                    onClick={() => {
                      setShowLogin(true);
                      setShowSignup(false);
                      setAuthError('');
                    }}
                    className="w-full bg-white/10 hover:bg-white/20 rounded-lg py-3 font-semibold transition-colors border border-white/20"
                  >
                    Sign In
                  </button>
                </div>
              )}

              {(showLogin || showSignup) && (
                <div className="bg-white/10 backdrop-blur rounded-2xl p-8">
                  <h2 className="text-2xl font-bold mb-6 text-center">
                    {showSignup ? 'Create Account' : 'Sign In'}
                  </h2>
                  
                  {authError && (
                    <div className="bg-red-500/20 border border-red-500/50 rounded-lg p-3 mb-4 text-sm">
                      {authError}
                    </div>
                  )}

                  <form onSubmit={showSignup ? handleSignUp : handleSignIn} className="space-y-4">
                    <div>
                      <input
                        type="email"
                        placeholder="Email"
                        value={email}
                        onChange={(e) => setEmail(e.target.value)}
                        required
                        className="w-full bg-white/20 rounded-lg px-4 py-3 text-white placeholder-slate-400 outline-none focus:ring-2 focus:ring-purple-400"
                      />
                    </div>
                    <div>
                      <input
                        type="password"
                        placeholder="Password"
                        value={password}
                        onChange={(e) => setPassword(e.target.value)}
                        required
                        minLength={6}
                        className="w-full bg-white/20 rounded-lg px-4 py-3 text-white placeholder-slate-400 outline-none focus:ring-2 focus:ring-purple-400"
                      />
                    </div>
                    <button
                      type="submit"
                      className="w-full bg-purple-500 hover:bg-purple-600 rounded-lg py-3 font-semibold transition-colors"
                    >
                      {showSignup ? 'Sign Up' : 'Sign In'}
                    </button>
                  </form>

                  <button
                    onClick={() => {
                      setShowLogin(false);
                      setShowSignup(false);
                      setEmail('');
                      setPassword('');
                      setAuthError('');
                    }}
                    className="w-full mt-4 text-slate-300 hover:text-white text-sm transition-colors"
                  >
                    Back
                  </button>
                </div>
              )}
            </div>
          </div>
        );
      }

      // Show loading while loading data
      if (loading) {
        return (
          <div className="min-h-screen bg-gradient-to-br from-slate-900 via-purple-900 to-slate-900 text-white flex items-center justify-center">
            <div className="text-2xl">Loading your drinks...</div>
          </div>
        );
      }

      return (
        <div className="min-h-screen bg-gradient-to-br from-slate-900 via-purple-900 to-slate-900 text-white">
          <div className="max-w-2xl mx-auto p-6 pb-24">
            <div className="flex items-center justify-between mb-8 pt-8">
              <div className="text-center flex-1">
                <h1 className="text-4xl font-bold mb-2">2026 Drink Tracker</h1>
                <p className="text-slate-300">Track every drink, understand your habits</p>
              </div>
              <div className="flex items-center gap-3">
                {/* Offline/Syncing indicators */}
                {!isOnline && (
                  <div className="flex items-center gap-2 bg-yellow-500/20 border border-yellow-500/50 rounded-lg px-3 py-1.5 text-xs">
                    <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M18.364 5.636a9 9 0 010 12.728m0 0l-2.829-2.829m2.829 2.829L21 21M15.536 8.464a5 5 0 010 7.072m0 0l-2.829-2.829m-4.243 2.829a4.978 4.978 0 01-1.414-2.83m-1.414 5.658a9 9 0 01-2.167-9.238m7.824 2.167a1 1 0 111.414 1.414m-1.414-1.414L3 3m8.293 8.293l1.414 1.414" />
                    </svg>
                    <span className="hidden sm:inline">Offline</span>
                  </div>
                )}
                {isSyncing && (
                  <div className="flex items-center gap-2 bg-blue-500/20 border border-blue-500/50 rounded-lg px-3 py-1.5 text-xs">
                    <svg className="w-4 h-4 animate-spin" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                    </svg>
                    <span className="hidden sm:inline">Syncing...</span>
                  </div>
                )}
                {cacheTimestamp && isOnline && !isSyncing && (
                  <div className="text-xs text-slate-400 hidden lg:inline" title={`Last synced: ${new Date(cacheTimestamp).toLocaleTimeString()}`}>
                    {Math.floor((Date.now() - cacheTimestamp) / 1000 / 60) < 1 ? 'Just now' : `${Math.floor((Date.now() - cacheTimestamp) / 1000 / 60)}m ago`}
                  </div>
                )}
                <span className="text-sm text-slate-300 hidden sm:inline">{user.email}</span>
                <button
                  onClick={handleSignOut}
                  className="bg-white/10 hover:bg-white/20 rounded-lg px-4 py-2 text-sm font-semibold transition-colors flex items-center gap-2"
                >
                  <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M17 16l4-4m0 0l-4-4m4 4H7m6 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h4a3 3 0 013 3v1" />
                  </svg>
                  Sign Out
                </button>
              </div>
            </div>

            {suggestion && !editMode && (
              <div className="bg-green-500/20 border border-green-500/50 backdrop-blur rounded-xl p-4 mb-6 flex items-center justify-between">
                <div className="flex-1">
                  <div className="font-semibold">Add to Quick Log?</div>
                  <div className="text-sm text-slate-300">
                    You've logged "{suggestion.name}" {suggestion.count} times
                  </div>
                </div>
                <div className="flex gap-2">
                  <button
                    onClick={() => addToQuickLog(suggestion.name, suggestion.category)}
                    className="bg-green-500 hover:bg-green-600 px-4 py-2 rounded-lg font-semibold transition-colors"
                  >
                    Add
                  </button>
                  <button
                    onClick={() => dismissSuggestion(suggestion.name)}
                    className="bg-white/20 hover:bg-white/30 px-4 py-2 rounded-lg transition-colors"
                  >
                    Dismiss
                  </button>
                </div>
              </div>
            )}

            <div className="bg-white/10 backdrop-blur rounded-2xl p-6 mb-6">
              <div className="flex items-center justify-between mb-4">
                <div>
                  <div className="text-slate-300 text-sm mb-1">Total in 2026</div>
                  <div className="text-5xl font-bold">{stats.total}</div>
                </div>
                <svg className="w-12 h-12 text-purple-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 7h8m0 0v8m0-8l-8 8-4-4-6 6" />
                </svg>
              </div>
              <div className="grid grid-cols-3 gap-4 pt-4 border-t border-white/20">
                <div className="text-center">
                  <div className="text-2xl font-bold text-amber-400">{stats.beer}</div>
                  <div className="text-xs text-slate-300 mt-1">Beer</div>
                </div>
                <div className="text-center">
                  <div className="text-2xl font-bold text-pink-400">{stats.cocktail}</div>
                  <div className="text-xs text-slate-300 mt-1">Cocktail</div>
                </div>
                <div className="text-center">
                  <div className="text-2xl font-bold text-red-400">{stats.wine}</div>
                  <div className="text-xs text-slate-300 mt-1">Wine</div>
                </div>
              </div>
            </div>

            <div className="mb-6">
              <div className="flex items-center justify-between mb-3">
                <h2 className="text-lg font-semibold text-slate-300">Quick Log</h2>
                <button
                  onClick={() => {
                    setEditMode(!editMode);
                    setEditingDrink(null);
                    setEditName('');
                    setEditCategory('');
                  }}
                  className="text-sm text-purple-400 hover:text-purple-300 flex items-center gap-1"
                >
                  <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" />
                  </svg>
                  {editMode ? 'Done' : 'Edit'}
                </button>
              </div>

              {editingDrink && (
                <div className="bg-white/10 backdrop-blur rounded-xl p-4 mb-3">
                  <div className="text-sm font-semibold mb-3">
                    {editingDrink === '__NEW__' ? 'Create New Quick Log Button' : 'Edit Drink'}
                  </div>
                  <input
                    type="text"
                    value={editName}
                    onChange={(e) => setEditName(e.target.value)}
                    className="w-full bg-white/20 rounded-lg px-4 py-3 mb-3 text-white placeholder-slate-400 outline-none focus:ring-2 focus:ring-purple-400"
                    placeholder="Drink name"
                    autoFocus
                  />
                  <div className="text-sm text-slate-300 mb-2">Category:</div>
                  <div className="flex gap-2 mb-3">
                    <button
                      onClick={() => setEditCategory('Beer')}
                      className={`flex-1 border rounded-lg py-2 font-semibold transition-colors ${
                        editCategory === 'Beer' 
                          ? 'bg-amber-500 border-amber-500' 
                          : 'bg-amber-500/20 border-amber-500/50 hover:bg-amber-500/40'
                      }`}
                    >
                      Beer
                    </button>
                    <button
                      onClick={() => setEditCategory('Cocktail')}
                      className={`flex-1 border rounded-lg py-2 font-semibold transition-colors ${
                        editCategory === 'Cocktail' 
                          ? 'bg-pink-500 border-pink-500' 
                          : 'bg-pink-500/20 border-pink-500/50 hover:bg-pink-500/40'
                      }`}
                    >
                      Cocktail
                    </button>
                    <button
                      onClick={() => setEditCategory('Wine')}
                      className={`flex-1 border rounded-lg py-2 font-semibold transition-colors ${
                        editCategory === 'Wine' 
                          ? 'bg-red-500 border-red-500' 
                          : 'bg-red-500/20 border-red-500/50 hover:bg-red-500/40'
                      }`}
                    >
                      Wine
                    </button>
                  </div>
                  <div className="flex gap-2">
                    <button
                      onClick={() => {
                        if (editingDrink === '__NEW__') {
                          createNewQuickLogDrink();
                        } else {
                          updateQuickLogDrink(editingDrink, editName, editCategory);
                        }
                      }}
                      className="flex-1 bg-purple-500 hover:bg-purple-600 rounded-lg py-2 font-semibold transition-colors"
                    >
                      {editingDrink === '__NEW__' ? 'Create' : 'Save'}
                    </button>
                    <button
                      onClick={() => {
                        setEditingDrink(null);
                        setEditName('');
                        setEditCategory('');
                      }}
                      className="px-6 bg-white/20 hover:bg-white/30 rounded-lg transition-colors"
                    >
                      Cancel
                    </button>
                  </div>
                </div>
              )}

              <div className="grid grid-cols-2 gap-3 mb-3">
                {quickLogDrinks.map((drink) => (
                  <div key={drink.name} className="relative">
                    <button
                      onClick={() => {
                        if (editMode) {
                          startEditingDrink(drink);
                        } else {
                          quickAddDrink(drink.name, drink.category);
                        }
                      }}
                      className={`w-full bg-white/10 backdrop-blur rounded-xl py-3 font-semibold transition-all ${
                        editMode ? 'hover:bg-white/20 ring-2 ring-purple-400/50' : 'hover:bg-purple-500 hover:scale-105 active:scale-95'
                      }`}
                    >
                      <div>{drink.name}</div>
                      <div className="text-xs text-slate-300 mt-1">{drink.category}</div>
                    </button>
                    {editMode && (
                      <button
                        onClick={() => removeFromQuickLog(drink.name)}
                        className="absolute -top-2 -right-2 bg-red-500 hover:bg-red-600 rounded-full p-1 shadow-lg"
                      >
                        <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                        </svg>
                      </button>
                    )}
                  </div>
                ))}
                
                {/* Add New Button - only shown in edit mode */}
                {editMode && !editingDrink && (
                  <button
                    onClick={startCreatingNewDrink}
                    className="w-full bg-white/10 backdrop-blur rounded-xl py-3 font-semibold transition-all hover:bg-white/20 ring-2 ring-dashed ring-purple-400/50 border-2 border-dashed border-purple-400/30 flex items-center justify-center gap-2"
                  >
                    <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" />
                    </svg>
                    <span>Add New</span>
                  </button>
                )}
              </div>
              
              {!editMode && (
                !showOtherForm ? (
                  <button
                    onClick={() => setShowOtherForm(true)}
                    className="w-full bg-white/10 backdrop-blur hover:bg-white/20 rounded-xl py-3 font-semibold transition-colors flex items-center justify-center gap-2"
                  >
                    <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" />
                    </svg>
                    Other
                  </button>
                ) : (
                  <div className="bg-white/10 backdrop-blur rounded-xl p-4">
                    <input
                      type="text"
                      placeholder="What did you drink?"
                      value={customDrink}
                      onChange={(e) => setCustomDrink(e.target.value)}
                      className="w-full bg-white/20 rounded-lg px-4 py-3 mb-3 text-white placeholder-slate-400 outline-none focus:ring-2 focus:ring-purple-400"
                      autoFocus
                    />
                    <div className="text-sm text-slate-300 mb-2">Select category:</div>
                    <div className="flex gap-2 mb-3">
                      <button
                        onClick={() => addCustomDrink('Beer')}
                        className="flex-1 bg-amber-500/20 hover:bg-amber-500 border border-amber-500/50 rounded-lg py-2 font-semibold transition-colors"
                      >
                        Beer
                      </button>
                      <button
                        onClick={() => addCustomDrink('Cocktail')}
                        className="flex-1 bg-pink-500/20 hover:bg-pink-500 border border-pink-500/50 rounded-lg py-2 font-semibold transition-colors"
                      >
                        Cocktail
                      </button>
                      <button
                        onClick={() => addCustomDrink('Wine')}
                        className="flex-1 bg-red-500/20 hover:bg-red-500 border border-red-500/50 rounded-lg py-2 font-semibold transition-colors"
                      >
                        Wine
                      </button>
                    </div>
                    <button
                      onClick={() => {
                        setShowOtherForm(false);
                        setCustomDrink('');
                      }}
                      className="w-full bg-white/20 hover:bg-white/30 rounded-lg py-2 transition-colors"
                    >
                      Cancel
                    </button>
                  </div>
                )
              )}
            </div>

            <div className="space-y-3">
              <div className="flex items-center justify-between mb-3">
                <div className="flex items-center gap-3">
                  <h2 className="text-lg font-semibold text-slate-300">History</h2>
                  {drinks.length > 0 && (
                    <span className="text-xs text-slate-400 bg-white/10 px-2 py-1 rounded">
                      {drinks.length} {drinks.length === 1 ? 'drink' : 'drinks'}
                    </span>
                  )}
                </div>
                {drinks.length > 0 && (
                  <button
                    onClick={exportToCSV}
                    className="text-sm text-purple-400 hover:text-purple-300 flex items-center gap-1 bg-white/10 hover:bg-white/20 px-3 py-1.5 rounded-lg transition-colors"
                  >
                    Export CSV
                  </button>
                )}
              </div>
              {drinks.length === 0 ? (
                <div className="text-center py-12 text-slate-400">
                  <svg className="w-16 h-16 mx-auto mb-4 opacity-50" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z" />
                  </svg>
                  <p>No drinks logged yet</p>
                  <p className="text-sm mt-2">Tap a button above to start tracking</p>
                </div>
              ) : (
                <>
                  {paginatedDrinks.map((drink) => (
                    <div
                      key={drink.id}
                      className="bg-white/10 backdrop-blur rounded-xl p-4 flex items-center justify-between hover:bg-white/15 transition-colors"
                    >
                      <div>
                        <div className="font-semibold text-lg">{drink.name}</div>
                        <div className="text-slate-300 text-sm">
                          {drink.category} • {formatDate(drink.timestamp)} at {formatTime(drink.timestamp)}
                        </div>
                      </div>
                      <button
                        onClick={() => deleteDrink(drink.id)}
                        className="text-red-400 hover:text-red-300 text-sm px-3 py-1 rounded-lg hover:bg-white/10 transition-colors"
                      >
                        Delete
                      </button>
                    </div>
                  ))}
                  
                  {/* Pagination Controls */}
                  {totalPages > 1 && (
                    <div className="flex items-center justify-center gap-2 mt-6 pt-6 border-t border-white/20">
                      <button
                        onClick={() => setCurrentPage(prev => Math.max(1, prev - 1))}
                        disabled={currentPage === 1}
                        className={`px-4 py-2 rounded-lg font-semibold transition-colors flex items-center gap-1 ${
                          currentPage === 1
                            ? 'bg-white/5 text-slate-500 cursor-not-allowed'
                            : 'bg-white/10 hover:bg-white/20 text-white'
                        }`}
                      >
                        <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 19l-7-7 7-7" />
                        </svg>
                        Previous
                      </button>
                      
                      <div className="flex items-center gap-1">
                        {Array.from({ length: totalPages }, (_, i) => i + 1).map((page) => {
                          // Show first page, last page, current page, and pages around current
                          if (
                            page === 1 ||
                            page === totalPages ||
                            (page >= currentPage - 1 && page <= currentPage + 1)
                          ) {
                            return (
                              <button
                                key={page}
                                onClick={() => setCurrentPage(page)}
                                className={`min-w-[2.5rem] px-3 py-2 rounded-lg font-semibold transition-colors ${
                                  currentPage === page
                                    ? 'bg-purple-500 text-white'
                                    : 'bg-white/10 hover:bg-white/20 text-white'
                                }`}
                              >
                                {page}
                              </button>
                            );
                          } else if (
                            page === currentPage - 2 ||
                            page === currentPage + 2
                          ) {
                            return (
                              <span key={page} className="px-2 text-slate-400">
                                ...
                              </span>
                            );
                          }
                          return null;
                        })}
                      </div>
                      
                      <button
                        onClick={() => setCurrentPage(prev => Math.min(totalPages, prev + 1))}
                        disabled={currentPage === totalPages}
                        className={`px-4 py-2 rounded-lg font-semibold transition-colors flex items-center gap-1 ${
                          currentPage === totalPages
                            ? 'bg-white/5 text-slate-500 cursor-not-allowed'
                            : 'bg-white/10 hover:bg-white/20 text-white'
                        }`}
                      >
                        Next
                        <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" />
                        </svg>
                      </button>
                    </div>
                  )}
                  
                  {/* Page info */}
                  {totalPages > 1 && (
                    <div className="text-center text-sm text-slate-400 mt-2">
                      Showing {startIndex + 1}-{Math.min(endIndex, drinks.length)} of {drinks.length} drinks
                    </div>
                  )}
                </>
              )}
            </div>
          </div>
        </div>
      );
    }

    console.log('[DEBUG] About to render DrinkTracker component');
    try {
      ReactDOM.render(<DrinkTracker />, document.getElementById('root'));
      console.log('[DEBUG] DrinkTracker component rendered successfully');
    } catch (error) {
      console.error('[DEBUG] Error rendering component:', error);
      alert('Error rendering app: ' + error.message);
    }
  </script>
</body>
</html>
