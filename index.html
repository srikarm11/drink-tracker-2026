<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>2026 Drink Tracker</title>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect } = React;

    // Supabase configuration
    const SUPABASE_URL = 'https://jftfalkxfsasptpoqztd.supabase.co';
    const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImpmdGZhbGt4ZnNhc3B0cG9xenRkIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjY3Njk0OTMsImV4cCI6MjA4MjM0NTQ5M30.zOMezm88s6GMvxVuyT1M0MK_kJKYOsIVg7m614jl_XI';
    
    const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY, {
      auth: {
        persistSession: true,
        autoRefreshToken: true,
        detectSessionInUrl: true,
        storage: window.localStorage,
        storageKey: 'sb-jftfalkxfsasptpoqztd-auth-token'
      }
    });

    function DrinkTracker() {
      const [user, setUser] = useState(null);
      const [session, setSession] = useState(null);
      const [authLoading, setAuthLoading] = useState(true);
      const [drinks, setDrinks] = useState([]);
      const [loading, setLoading] = useState(true);
      const [showOtherForm, setShowOtherForm] = useState(false);
      const [customDrink, setCustomDrink] = useState('');
      const [quickLogDrinks, setQuickLogDrinks] = useState([
        { name: 'Martini', category: 'Cocktail' },
        { name: 'Gin & Tonic', category: 'Cocktail' },
        { name: 'Guinness', category: 'Beer' },
        { name: 'Narragansett', category: 'Beer' },
        { name: 'White Wine', category: 'Wine' },
        { name: 'Red Wine', category: 'Wine' }
      ]);
      const [dismissedSuggestions, setDismissedSuggestions] = useState([]);
      const [editMode, setEditMode] = useState(false);
      const [editingDrink, setEditingDrink] = useState(null);
      const [editName, setEditName] = useState('');
      const [editCategory, setEditCategory] = useState('');
      
      // Pagination state
      const [currentPage, setCurrentPage] = useState(1);
      const itemsPerPage = 10;
      
      // Auth form state
      const [showLogin, setShowLogin] = useState(false);
      const [showSignup, setShowSignup] = useState(false);
      const [email, setEmail] = useState('');
      const [password, setPassword] = useState('');
      const [authError, setAuthError] = useState('');
      
      // Caching and offline state
      const [isOnline, setIsOnline] = useState(navigator.onLine);
      const [isSyncing, setIsSyncing] = useState(false);
      const [cacheTimestamp, setCacheTimestamp] = useState(null);
      const CACHE_VALIDITY_MS = 5 * 60 * 1000; // 5 minutes
      
      // Bulk delete state
      const [showBulkDelete, setShowBulkDelete] = useState(false);
      const [deleteStartDate, setDeleteStartDate] = useState('');
      const [deleteEndDate, setDeleteEndDate] = useState('');
      const [deleting, setDeleting] = useState(false);
      
      // Dashboard state
      const [dashboardPeriod, setDashboardPeriod] = useState('all'); // 'week' | 'month' | 'year' | 'all'
      const [dashboardCategoryFilter, setDashboardCategoryFilter] = useState('all'); // 'all' | 'Beer' | 'Wine' | 'Cocktail'
      const [dashboardSearchQuery, setDashboardSearchQuery] = useState('');
      const [dashboardPresetPeriod, setDashboardPresetPeriod] = useState('all'); // 'thisWeek' | 'thisMonth' | 'last30Days' | 'thisYear' | 'all'

      // Check for existing session on mount
      // Note: We rely on onAuthStateChange INITIAL_SESSION event, but also call checkSession as backup
      useEffect(() => {
        // Wait a moment for Supabase to initialize, then check session
        const timer = setTimeout(() => {
          checkSession();
        }, 500);
        
        return () => clearTimeout(timer);
      }, []);

      // Offline/online detection
      useEffect(() => {
        const handleOnline = () => setIsOnline(true);
        const handleOffline = () => setIsOnline(false);
        
        window.addEventListener('online', handleOnline);
        window.addEventListener('offline', handleOffline);
        
        return () => {
          window.removeEventListener('online', handleOnline);
          window.removeEventListener('offline', handleOffline);
        };
      }, []);

      // Sync when coming back online
      useEffect(() => {
        if (isOnline && user) {
          syncWhenOnline();
        }
      }, [isOnline, user?.id]);

      // Load data when user is available
      useEffect(() => {
        if (user) {
          loadData();
        }
      }, [user]);


      const checkSession = async () => {
        try {
          // Get the session - Supabase handles persistence automatically
          const { data: { session }, error } = await supabase.auth.getSession();
          
          if (error) {
            console.error('Error getting session:', error);
            setSession(null);
            setUser(null);
            setAuthLoading(false);
            return;
          }
          
          // If we have a session, restore it
          if (session && session.user) {
            setSession(session);
            setUser(session.user);
            loadCachedDrinks(session.user.id);
          } else {
            // Don't clear state if user already exists (might have been set by INITIAL_SESSION handler)
            if (!user) {
              setSession(null);
              setUser(null);
            }
          }
        } catch (error) {
          console.error('Error checking session:', error);
          if (!user) {
            setSession(null);
            setUser(null);
          }
        } finally {
          setAuthLoading(false);
        }
      };

      const handleSignUp = async (e) => {
        e.preventDefault();
        setAuthError('');
        
        try {
          const { data, error } = await supabase.auth.signUp({
            email: email,
            password: password,
            options: {
              emailRedirectTo: `${window.location.origin}${window.location.pathname}`
            }
          });

          if (error) throw error;

          if (data.user) {
            // If session exists, user is immediately signed in (email confirmation disabled)
            // If no session, user needs to confirm email first
            if (data.session) {
              setUser(data.user);
              setSession(data.session);
              setShowSignup(false);
              setEmail('');
              setPassword('');
            } else {
              // Email confirmation required
              setShowSignup(false);
              setEmail('');
              setPassword('');
              alert('Account created! Please check your email to confirm your account before signing in.');
            }
          }
        } catch (error) {
          setAuthError(error.message);
          console.error('Error signing up:', error);
        }
      };

      const handleSignIn = async (e) => {
        e.preventDefault();
        setAuthError('');
        
        try {
          const { data, error } = await supabase.auth.signInWithPassword({
            email: email,
            password: password,
          });

          if (error) throw error;

          if (data.user && data.session) {
            setUser(data.user);
            setSession(data.session);
            setShowLogin(false);
            setEmail('');
            setPassword('');
          } else {
            setAuthError('Sign in succeeded but session was not created. Please try again.');
          }
        } catch (error) {
          setAuthError(error.message);
          console.error('Error signing in:', error);
        }
      };

      const handleSignOut = async () => {
        try {
          // Clear cached data before signing out
          if (user) {
            const userId = user.id;
            localStorage.removeItem(`drinks-cache-2026-${userId}`);
            localStorage.removeItem(`drinks-cache-timestamp-2026-${userId}`);
            localStorage.removeItem(`quicklog-2026-${userId}`);
            localStorage.removeItem(`dismissed-suggestions-2026-${userId}`);
          }
          
          const { error } = await supabase.auth.signOut();
          if (error) throw error;
          
          setUser(null);
          setSession(null);
          setDrinks([]);
          setCacheTimestamp(null);
          setQuickLogDrinks([
            { name: 'Martini', category: 'Cocktail' },
            { name: 'Gin & Tonic', category: 'Cocktail' },
            { name: 'Guinness', category: 'Beer' },
            { name: 'Narragansett', category: 'Beer' },
            { name: 'White Wine', category: 'Wine' },
            { name: 'Red Wine', category: 'Wine' }
          ]);
          setDismissedSuggestions([]);
        } catch (error) {
          console.error('Error signing out:', error);
        }
      };

      // Listen for auth changes (including email confirmation)
      useEffect(() => {
        const { data: { subscription } } = supabase.auth.onAuthStateChange((event, session) => {
          // Handle different auth events
          if (event === 'SIGNED_IN' && session) {
            setSession(session);
            setUser(session.user);
          } else if (event === 'TOKEN_REFRESHED' && session) {
            setSession(session);
            setUser(session.user);
          } else if (event === 'SIGNED_OUT') {
            // Clear all cached data on sign out
            if (user) {
              const userId = user.id;
              localStorage.removeItem(`drinks-cache-2026-${userId}`);
              localStorage.removeItem(`drinks-cache-timestamp-2026-${userId}`);
            }
            setSession(null);
            setUser(null);
            setDrinks([]);
            setCacheTimestamp(null);
          } else if (event === 'INITIAL_SESSION') {
            // This fires when Supabase restores a session from storage
            if (session && session.user) {
              setSession(session);
              setUser(session.user);
              setAuthLoading(false);
              loadCachedDrinks(session.user.id);
            } else {
              // INITIAL_SESSION fired but session is null - try to restore from localStorage
              const supabaseKey = 'sb-jftfalkxfsasptpoqztd-auth-token';
              const stored = localStorage.getItem(supabaseKey);
              
              if (stored) {
                try {
                  const parsed = JSON.parse(stored);
                  const storedSession = parsed?.currentSession;
                  
                  if (storedSession && storedSession.user) {
                    // Check if expired
                    const expiresAt = storedSession.expires_at;
                    if (expiresAt) {
                      const now = Math.floor(Date.now() / 1000);
                      if (expiresAt < now) {
                        // Try to refresh expired session
                        supabase.auth.refreshSession().then(({ data: { session: refreshed }, error }) => {
                          if (error || !refreshed) {
                            setSession(null);
                            setUser(null);
                            setAuthLoading(false);
                          } else {
                            setSession(refreshed);
                            setUser(refreshed.user);
                            setAuthLoading(false);
                            loadCachedDrinks(refreshed.user.id);
                          }
                        });
                        return;
                      }
                    }
                    
                    // Restore session from localStorage
                    setSession(storedSession);
                    setUser(storedSession.user);
                    setAuthLoading(false);
                    loadCachedDrinks(storedSession.user.id);
                  } else {
                    setSession(null);
                    setUser(null);
                    setAuthLoading(false);
                  }
                } catch (e) {
                  console.error('Error parsing localStorage:', e);
                  setSession(null);
                  setUser(null);
                  setAuthLoading(false);
                }
              } else {
                setSession(null);
                setUser(null);
                setAuthLoading(false);
              }
            }
          } else {
            // For other events, update state if we have a session
            if (session) {
              setSession(session);
              setUser(session.user);
            }
          }
        });

        return () => subscription.unsubscribe();
      }, []);

      const cacheDrinksData = (drinksData, userId) => {
        if (!userId) return;
        try {
          const cacheKey = `drinks-cache-2026-${userId}`;
          const timestampKey = `drinks-cache-timestamp-2026-${userId}`;
          localStorage.setItem(cacheKey, JSON.stringify(drinksData));
          localStorage.setItem(timestampKey, Date.now().toString());
          setCacheTimestamp(Date.now());
        } catch (error) {
          console.error('Error caching drinks data:', error);
        }
      };

      const loadCachedDrinks = (userId) => {
        if (!userId) return null;
        try {
          const cacheKey = `drinks-cache-2026-${userId}`;
          const timestampKey = `drinks-cache-timestamp-2026-${userId}`;
          const cached = localStorage.getItem(cacheKey);
          const timestamp = localStorage.getItem(timestampKey);
          
          if (cached && timestamp) {
            const cacheAge = Date.now() - parseInt(timestamp);
            const cachedData = JSON.parse(cached);
            
            // Return cached data if it's still valid
            if (cacheAge < CACHE_VALIDITY_MS) {
              setDrinks(cachedData);
              setCacheTimestamp(parseInt(timestamp));
              return cachedData;
            }
          }
        } catch (error) {
          console.error('Error loading cached drinks:', error);
        }
        return null;
      };

      const checkOnlineStatus = () => {
        return navigator.onLine;
      };

      const syncWhenOnline = async () => {
        if (!isOnline || isSyncing) return;
        
        setIsSyncing(true);
        try {
          // Get current session to ensure we're authenticated
          const { data: { session: currentSession } } = await supabase.auth.getSession();
          if (!currentSession || !currentSession.user) {
            setIsSyncing(false);
            return;
          }
          
          // Reload fresh data from server
          const { data: drinksData, error } = await supabase
            .from('drinks')
            .select('*')
            .eq('user_id', currentSession.user.id)
            .order('timestamp', { ascending: false });

          if (error) throw error;
          
          if (drinksData) {
            setDrinks(drinksData);
            cacheDrinksData(drinksData, currentSession.user.id);
          }
        } catch (error) {
          console.error('Error syncing data:', error);
        } finally {
          setIsSyncing(false);
        }
      };

      const loadData = async () => {
        if (!user) {
          setLoading(false);
          return;
        }

        // First, try to load cached data for instant display
        const cachedData = loadCachedDrinks(user.id);
        if (cachedData && cachedData.length > 0) {
          setLoading(false); // Show cached data immediately
        }

        try {
          // Then fetch fresh data from Supabase
          const { data: drinksData, error } = await supabase
            .from('drinks')
            .select('*')
            .eq('user_id', user.id)
            .order('timestamp', { ascending: false });

          if (error) {
            // If offline or network error, use cached data
            if (!isOnline || error.message.includes('fetch')) {
              console.warn('Network error, using cached data');
              if (!cachedData || cachedData.length === 0) {
                setLoading(false);
              }
              return;
            }
            throw error;
          }
          
          if (drinksData) {
            setDrinks(drinksData);
            cacheDrinksData(drinksData, user.id);
          }

          // Load quick log and dismissed from localStorage (user-specific)
          const userKey = `quicklog-2026-${user.id}`;
          const storedQuickLog = localStorage.getItem(userKey);
          if (storedQuickLog) {
            setQuickLogDrinks(JSON.parse(storedQuickLog));
          }

          const dismissedKey = `dismissed-suggestions-2026-${user.id}`;
          const storedDismissed = localStorage.getItem(dismissedKey);
          if (storedDismissed) {
            setDismissedSuggestions(JSON.parse(storedDismissed));
          }
        } catch (error) {
          console.error('Error loading data:', error);
          // Show error to user if it's a critical issue
          if (error.message && (error.message.includes('column') || error.message.includes('permission'))) {
            alert(`Database error: ${error.message}\n\nPlease check your Supabase setup. See SUPABASE_SETUP.md for instructions.`);
          }
        } finally {
          setLoading(false);
        }
      };

      const saveQuickLog = (newQuickLog) => {
        if (!user) return;
        const userKey = `quicklog-2026-${user.id}`;
        localStorage.setItem(userKey, JSON.stringify(newQuickLog));
      };

      const saveDismissed = (newDismissed) => {
        if (!user) return;
        const dismissedKey = `dismissed-suggestions-2026-${user.id}`;
        localStorage.setItem(dismissedKey, JSON.stringify(newDismissed));
      };

      const normalizeDrinkName = (name) => {
        return name.toLowerCase().trim();
      };

      const quickAddDrink = async (name, category) => {
        if (!user) return;
        
        try {
          // Get current session to ensure we use the authenticated user ID
          const { data: { session: currentSession } } = await supabase.auth.getSession();
          
          if (!currentSession || !currentSession.access_token) {
            throw new Error('No valid session found. Please sign in again.');
          }
          
          const newDrink = {
            name: name,
            category: category,
            timestamp: new Date().toISOString(),
            user_id: currentSession.user.id
          };

          const { data, error } = await supabase
            .from('drinks')
            .insert([newDrink])
            .select();

          if (error) throw error;

          if (data) {
            const updatedDrinks = [data[0], ...drinks];
            setDrinks(updatedDrinks);
            // Update cache
            cacheDrinksData(updatedDrinks, currentSession.user.id);
          }
        } catch (error) {
          console.error('Error adding drink:', error);
          const errorMessage = error.message || 'Unknown error occurred';
          
          // If offline, queue the action
          if (!isOnline || error.message.includes('fetch')) {
            alert('You are offline. The drink will be saved when you reconnect.');
            // Could implement offline queue here
            return;
          }
          
          alert(`Failed to add drink: ${errorMessage}\n\nCheck the browser console (F12) for more details.\n\nIf you see "column" or "permission" errors, you may need to set up your Supabase database. See SUPABASE_SETUP.md for instructions.`);
        }
      };

      const addCustomDrink = async (category) => {
        if (!customDrink.trim() || !user) return;
        
        try {
          // Get current session to ensure we use the authenticated user ID
          const { data: { session: currentSession } } = await supabase.auth.getSession();
          
          if (!currentSession || !currentSession.access_token) {
            throw new Error('No valid session found. Please sign in again.');
          }
          
          const newDrink = {
            name: customDrink.trim(),
            category: category,
            timestamp: new Date().toISOString(),
            user_id: currentSession.user.id
          };

          const { data, error } = await supabase
            .from('drinks')
            .insert([newDrink])
            .select();

          if (error) throw error;

          if (data) {
            const updatedDrinks = [data[0], ...drinks];
            setDrinks(updatedDrinks);
            // Update cache
            cacheDrinksData(updatedDrinks, currentSession.user.id);
          }
          
          setCustomDrink('');
          setShowOtherForm(false);
        } catch (error) {
          console.error('Error adding drink:', error);
          const errorMessage = error.message || 'Unknown error occurred';
          
          // If offline, queue the action
          if (!isOnline || error.message.includes('fetch')) {
            alert('You are offline. The drink will be saved when you reconnect.');
            return;
          }
          
          alert(`Failed to add drink: ${errorMessage}\n\nCheck the browser console (F12) for more details.\n\nIf you see "column" or "permission" errors, you may need to set up your Supabase database. See SUPABASE_SETUP.md for instructions.`);
        }
      };

      const deleteDrink = async (id) => {
        if (!user) return;
        
        try {
          const { error } = await supabase
            .from('drinks')
            .delete()
            .eq('id', id)
            .eq('user_id', user.id); // Ensure user can only delete their own drinks

          if (error) throw error;

          const updatedDrinks = drinks.filter(d => d.id !== id);
          setDrinks(updatedDrinks);
          // Update cache
          cacheDrinksData(updatedDrinks, user.id);
        } catch (error) {
          console.error('Error deleting drink:', error);
          
          // If offline, show message
          if (!isOnline || error.message.includes('fetch')) {
            alert('You are offline. The deletion will be synced when you reconnect.');
            return;
          }
          
          alert('Failed to delete drink. Please try again.');
        }
      };

      const getDrinksInDateRange = (startDate, endDate) => {
        if (!startDate || !endDate) return { count: 0, drinks: [] };
        
        const start = new Date(startDate);
        const end = new Date(endDate);
        // Set end date to end of day
        end.setHours(23, 59, 59, 999);
        
        const filtered = drinks.filter(drink => {
          const drinkDate = new Date(drink.timestamp);
          return drinkDate >= start && drinkDate <= end;
        });
        
        return {
          count: filtered.length,
          drinks: filtered
        };
      };

      const deleteDrinksByDateRange = async (startDate, endDate) => {
        if (!user) return;
        
        // Validate date range
        if (!startDate || !endDate) {
          alert('Please select both start and end dates.');
          return;
        }
        
        const start = new Date(startDate);
        const end = new Date(endDate);
        
        if (start > end) {
          alert('Start date must be before or equal to end date.');
          return;
        }
        
        const { count, drinks: drinksToDelete } = getDrinksInDateRange(startDate, endDate);
        
        if (count === 0) {
          alert('No drinks found in the selected date range.');
          return;
        }
        
        // Check if offline
        if (!isOnline) {
          alert('You are offline. Bulk deletion requires an internet connection. Please try again when online.');
          return;
        }
        
        setDeleting(true);
        
        try {
          // Delete all drinks in the date range
          const drinkIds = drinksToDelete.map(d => d.id);
          
          // Supabase doesn't support bulk delete with array of IDs directly,
          // so we'll use .in() filter
          const { error } = await supabase
            .from('drinks')
            .delete()
            .in('id', drinkIds)
            .eq('user_id', user.id); // Ensure user can only delete their own drinks

          if (error) throw error;

          // Update local state
          const updatedDrinks = drinks.filter(d => !drinkIds.includes(d.id));
          setDrinks(updatedDrinks);
          
          // Update cache
          cacheDrinksData(updatedDrinks, user.id);
          
          // Reset pagination if needed
          const newTotalPages = Math.ceil(updatedDrinks.length / itemsPerPage);
          if (currentPage > newTotalPages && newTotalPages > 0) {
            setCurrentPage(newTotalPages);
          } else if (newTotalPages === 0) {
            setCurrentPage(1);
          }
          
          // Close modal and reset dates
          setShowBulkDelete(false);
          setDeleteStartDate('');
          setDeleteEndDate('');
          
          alert(`Successfully deleted ${count} drink${count === 1 ? '' : 's'}.`);
        } catch (error) {
          console.error('Error deleting drinks:', error);
          alert(`Failed to delete drinks: ${error.message}`);
        } finally {
          setDeleting(false);
        }
      };

      const deleteAllDrinks = async () => {
        if (!user) return;
        
        if (drinks.length === 0) {
          alert('No drinks to delete.');
          return;
        }
        
        // Double confirmation for deleting all
        const confirmMessage = `Are you sure you want to delete ALL ${drinks.length} drink${drinks.length === 1 ? '' : 's'}? This action cannot be undone.`;
        if (!confirm(confirmMessage)) {
          return;
        }
        
        // Check if offline
        if (!isOnline) {
          alert('You are offline. Deleting all drinks requires an internet connection. Please try again when online.');
          return;
        }
        
        setDeleting(true);
        
        try {
          const drinkCount = drinks.length;
          
          // Delete all drinks for this user - simpler approach that doesn't require ID array
          const { error } = await supabase
            .from('drinks')
            .delete()
            .eq('user_id', user.id); // RLS ensures user can only delete their own drinks

          if (error) throw error;

          // Update local state
          setDrinks([]);
          
          // Update cache
          cacheDrinksData([], user.id);
          
          // Reset pagination
          setCurrentPage(1);
          
          // Close modal
          setShowBulkDelete(false);
          setDeleteStartDate('');
          setDeleteEndDate('');
          
          alert(`Successfully deleted all ${drinkCount} drink${drinkCount === 1 ? '' : 's'}.`);
        } catch (error) {
          console.error('Error deleting all drinks:', error);
          alert(`Failed to delete all drinks: ${error.message}`);
        } finally {
          setDeleting(false);
        }
      };

      const removeFromQuickLog = (drinkName) => {
        const updated = quickLogDrinks.filter(d => d.name !== drinkName);
        setQuickLogDrinks(updated);
        saveQuickLog(updated);
      };

      const updateQuickLogDrink = (oldName, newName, newCategory) => {
        if (!newName.trim() || !newCategory) return;
        
        // Check for duplicates (excluding the drink being edited)
        const normalizedNewName = normalizeDrinkName(newName);
        const isDuplicate = quickLogDrinks.some(d => 
          normalizeDrinkName(d.name) === normalizedNewName && d.name !== oldName
        );
        
        if (isDuplicate) {
          alert('A drink with this name already exists in Quick Log.');
          return;
        }
        
        const updated = quickLogDrinks.map(d => 
          d.name === oldName ? { name: newName.trim(), category: newCategory } : d
        );
        setQuickLogDrinks(updated);
        saveQuickLog(updated);
        setEditingDrink(null);
        setEditName('');
        setEditCategory('');
      };

      const createNewQuickLogDrink = () => {
        if (!editName.trim() || !editCategory) {
          alert('Please enter a drink name and select a category.');
          return;
        }
        
        // Check for duplicates
        const normalizedNewName = normalizeDrinkName(editName);
        const isDuplicate = quickLogDrinks.some(d => 
          normalizeDrinkName(d.name) === normalizedNewName
        );
        
        if (isDuplicate) {
          alert('A drink with this name already exists in Quick Log.');
          return;
        }
        
        const updated = [...quickLogDrinks, { name: editName.trim(), category: editCategory }];
        setQuickLogDrinks(updated);
        saveQuickLog(updated);
        setEditingDrink(null);
        setEditName('');
        setEditCategory('');
      };

      const startEditingDrink = (drink) => {
        setEditingDrink(drink.name);
        setEditName(drink.name);
        setEditCategory(drink.category);
      };

      const startCreatingNewDrink = () => {
        setEditingDrink('__NEW__');
        setEditName('');
        setEditCategory('');
      };

      const addToQuickLog = (drinkName, category) => {
        const updated = [...quickLogDrinks, { name: drinkName, category: category }];
        setQuickLogDrinks(updated);
        saveQuickLog(updated);
      };

      const dismissSuggestion = (drinkName) => {
        const updated = [...dismissedSuggestions, normalizeDrinkName(drinkName)];
        setDismissedSuggestions(updated);
        saveDismissed(updated);
      };

      const getSuggestion = () => {
        const drinkCounts = {};
        
        drinks.forEach(drink => {
          const normalized = normalizeDrinkName(drink.name);
          const isInQuickLog = quickLogDrinks.some(qd => normalizeDrinkName(qd.name) === normalized);
          const isDismissed = dismissedSuggestions.includes(normalized);
          
          if (!isInQuickLog && !isDismissed) {
            if (!drinkCounts[normalized]) {
              drinkCounts[normalized] = { count: 0, originalName: drink.name, category: drink.category };
            }
            drinkCounts[normalized].count++;
          }
        });

        for (const [normalized, data] of Object.entries(drinkCounts)) {
          if (data.count >= 3) {
            return { name: data.originalName, category: data.category, count: data.count };
          }
        }
        return null;
      };

      const suggestion = getSuggestion();

      const exportToCSV = () => {
        if (drinks.length === 0) {
          alert('No drinks to export yet!');
          return;
        }

        const headers = ['Name', 'Category', 'Date', 'Time', 'Timestamp'];
        const rows = drinks.map(drink => {
          const date = new Date(drink.timestamp);
          const dateStr = date.toLocaleDateString('en-US');
          const timeStr = date.toLocaleTimeString('en-US');
          return [
            drink.name,
            drink.category,
            dateStr,
            timeStr,
            drink.timestamp
          ];
        });

        const csvContent = [
          headers.join(','),
          ...rows.map(row => row.map(cell => `"${cell}"`).join(','))
        ].join('\n');

        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement('a');
        const url = URL.createObjectURL(blob);
        link.setAttribute('href', url);
        link.setAttribute('download', `drink-tracker-${new Date().toISOString().split('T')[0]}.csv`);
        link.style.visibility = 'hidden';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      };

      const formatDate = (timestamp) => {
        const date = new Date(timestamp);
        const today = new Date();
        const yesterday = new Date(today);
        yesterday.setDate(yesterday.getDate() - 1);

        if (date.toDateString() === today.toDateString()) {
          return 'Today';
        } else if (date.toDateString() === yesterday.toDateString()) {
          return 'Yesterday';
        } else {
          return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
        }
      };

      const formatTime = (timestamp) => {
        return new Date(timestamp).toLocaleTimeString('en-US', { 
          hour: 'numeric', 
          minute: '2-digit',
          hour12: true 
        });
      };

      const getFilteredDrinks = () => {
        // Guard against undefined or null drinks array
        if (!drinks || !Array.isArray(drinks)) {
          return [];
        }
        let filtered = [...drinks];

        // Apply category filter
        if (dashboardCategoryFilter !== 'all') {
          filtered = filtered.filter(d => d.category === dashboardCategoryFilter);
        }

        // Apply search query
        if (dashboardSearchQuery.trim()) {
          const query = dashboardSearchQuery.toLowerCase().trim();
          filtered = filtered.filter(d => 
            d.name.toLowerCase().includes(query)
          );
        }

        // Apply date range based on preset period
        if (dashboardPresetPeriod !== 'all') {
          const now = new Date();
          const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
          
          let startDate, endDate;
          
          switch (dashboardPresetPeriod) {
            case 'thisWeek':
              // Start of this week (Sunday)
              const dayOfWeek = today.getDay();
              startDate = new Date(today);
              startDate.setDate(today.getDate() - dayOfWeek);
              startDate.setHours(0, 0, 0, 0);
              endDate = new Date(now);
              endDate.setHours(23, 59, 59, 999);
              break;
              
            case 'thisMonth':
              startDate = new Date(today.getFullYear(), today.getMonth(), 1);
              startDate.setHours(0, 0, 0, 0);
              endDate = new Date(now);
              endDate.setHours(23, 59, 59, 999);
              break;
              
            case 'last30Days':
              startDate = new Date(today);
              startDate.setDate(today.getDate() - 30);
              startDate.setHours(0, 0, 0, 0);
              endDate = new Date(now);
              endDate.setHours(23, 59, 59, 999);
              break;
              
            case 'thisYear':
              startDate = new Date(today.getFullYear(), 0, 1);
              startDate.setHours(0, 0, 0, 0);
              endDate = new Date(now);
              endDate.setHours(23, 59, 59, 999);
              break;
              
            default:
              return filtered;
          }
          
          filtered = filtered.filter(drink => {
            const drinkDate = new Date(drink.timestamp);
            return drinkDate >= startDate && drinkDate <= endDate;
          });
        }

        return filtered;
      };

      const calculateWeeklyStats = (filteredDrinks) => {
        if (!filteredDrinks || filteredDrinks.length === 0) {
          return [];
        }
        const weeklyMap = new Map();
        
        filteredDrinks.forEach(drink => {
          const date = new Date(drink.timestamp);
          const year = date.getFullYear();
          const weekStart = new Date(date);
          weekStart.setDate(date.getDate() - date.getDay()); // Start of week (Sunday)
          weekStart.setHours(0, 0, 0, 0);
          
          const weekKey = `${year}-W${getWeekNumber(weekStart)}`;
          
          if (!weeklyMap.has(weekKey)) {
            weeklyMap.set(weekKey, {
              week: weekKey,
              startDate: new Date(weekStart),
              count: 0,
              drinks: []
            });
          }
          
          const weekData = weeklyMap.get(weekKey);
          weekData.count++;
          weekData.drinks.push(drink);
        });
        
        return Array.from(weeklyMap.values()).sort((a, b) => 
          b.startDate.getTime() - a.startDate.getTime()
        );
      };

      const calculateMonthlyStats = (filteredDrinks) => {
        if (!filteredDrinks || filteredDrinks.length === 0) {
          return [];
        }
        const monthlyMap = new Map();
        
        filteredDrinks.forEach(drink => {
          const date = new Date(drink.timestamp);
          const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
          
          if (!monthlyMap.has(monthKey)) {
            monthlyMap.set(monthKey, {
              month: monthKey,
              monthName: date.toLocaleDateString('en-US', { month: 'long', year: 'numeric' }),
              count: 0,
              drinks: []
            });
          }
          
          const monthData = monthlyMap.get(monthKey);
          monthData.count++;
          monthData.drinks.push(drink);
        });
        
        return Array.from(monthlyMap.values()).sort((a, b) => 
          b.month.localeCompare(a.month)
        );
      };

      const calculateYearlyStats = (filteredDrinks) => {
        if (!filteredDrinks || filteredDrinks.length === 0) {
          return [];
        }
        const yearlyMap = new Map();
        
        filteredDrinks.forEach(drink => {
          const date = new Date(drink.timestamp);
          const year = date.getFullYear().toString();
          
          if (!yearlyMap.has(year)) {
            yearlyMap.set(year, {
              year: year,
              count: 0,
              drinks: []
            });
          }
          
          const yearData = yearlyMap.get(year);
          yearData.count++;
          yearData.drinks.push(drink);
        });
        
        return Array.from(yearlyMap.values()).sort((a, b) => 
          parseInt(b.year) - parseInt(a.year)
        );
      };

      const calculateDailyAverage = (filteredDrinks, period) => {
        if (!filteredDrinks || filteredDrinks.length === 0) return 0;
        
        const dates = filteredDrinks.map(d => {
          const date = new Date(d.timestamp);
          return new Date(date.getFullYear(), date.getMonth(), date.getDate()).getTime();
        });
        
        const uniqueDays = new Set(dates).size;
        
        if (uniqueDays === 0) return 0;
        
        return (filteredDrinks.length / uniqueDays).toFixed(2);
      };

      const calculateStreak = (filteredDrinks) => {
        if (!filteredDrinks || filteredDrinks.length === 0) {
          return { currentStreak: 0, longestStreak: 0, lastDrinkDate: null };
        }
        
        // Get unique dates
        const drinkDates = filteredDrinks.map(d => {
          const date = new Date(d.timestamp);
          return new Date(date.getFullYear(), date.getMonth(), date.getDate()).getTime();
        });
        
        const uniqueDates = Array.from(new Set(drinkDates)).sort((a, b) => b - a);
        
        // Calculate current streak (consecutive days from today backwards)
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        const todayTime = today.getTime();
        
        let currentStreak = 0;
        let checkDate = todayTime;
        
        while (uniqueDates.includes(checkDate)) {
          currentStreak++;
          checkDate -= 24 * 60 * 60 * 1000; // Subtract one day
        }
        
        // Calculate longest streak
        let longestStreak = 1;
        let tempStreak = 1;
        
        for (let i = 1; i < uniqueDates.length; i++) {
          const dayDiff = (uniqueDates[i - 1] - uniqueDates[i]) / (24 * 60 * 60 * 1000);
          if (dayDiff === 1) {
            tempStreak++;
            longestStreak = Math.max(longestStreak, tempStreak);
          } else {
            tempStreak = 1;
          }
        }
        
        return {
          currentStreak,
          longestStreak,
          lastDrinkDate: new Date(Math.max(...uniqueDates))
        };
      };

      const calculatePeakDays = (filteredDrinks) => {
        if (!filteredDrinks || filteredDrinks.length === 0) {
          const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
          return {
            dayOfWeek: {
              peak: 'N/A',
              count: 0,
              all: dayNames.map((name, idx) => ({ name, count: 0 }))
            },
            dayOfMonth: {
              peak: 0,
              count: 0,
              all: []
            }
          };
        }

        const dayOfWeekCount = { 0: 0, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0 }; // Sun-Sat
        const dayOfMonthCount = {};
        
        filteredDrinks.forEach(drink => {
          const date = new Date(drink.timestamp);
          const dayOfWeek = date.getDay();
          const dayOfMonth = date.getDate();
          
          dayOfWeekCount[dayOfWeek]++;
          
          if (!dayOfMonthCount[dayOfMonth]) {
            dayOfMonthCount[dayOfMonth] = 0;
          }
          dayOfMonthCount[dayOfMonth]++;
        });
        
        const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
        
        // Find peak day of week (with fallback)
        const peakDayOfWeek = Object.keys(dayOfWeekCount).length > 0
          ? Object.keys(dayOfWeekCount).reduce((a, b) => 
              dayOfWeekCount[a] > dayOfWeekCount[b] ? a : b
            )
          : '0';
        
        // Find peak day of month (with fallback)
        const peakDayOfMonth = Object.keys(dayOfMonthCount).length > 0
          ? Object.keys(dayOfMonthCount).reduce((a, b) => 
              dayOfMonthCount[a] > dayOfMonthCount[b] ? a : b
            )
          : '1';
        
        return {
          dayOfWeek: {
            peak: dayNames[parseInt(peakDayOfWeek)],
            count: dayOfWeekCount[peakDayOfWeek] || 0,
            all: dayNames.map((name, idx) => ({ name, count: dayOfWeekCount[idx] }))
          },
          dayOfMonth: {
            peak: parseInt(peakDayOfMonth),
            count: dayOfMonthCount[peakDayOfMonth] || 0,
            all: Object.keys(dayOfMonthCount).map(day => ({
              day: parseInt(day),
              count: dayOfMonthCount[day]
            })).sort((a, b) => a.day - b.day)
          }
        };
      };

      // Helper function to get week number
      const getWeekNumber = (date) => {
        const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
        const dayNum = d.getUTCDay() || 7;
        d.setUTCDate(d.getUTCDate() + 4 - dayNum);
        const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
        return Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
      };

      const getStats = () => {
        const filtered = getFilteredDrinks();
        const total = filtered.length;
        const beer = filtered.filter(d => d.category === 'Beer').length;
        const wine = filtered.filter(d => d.category === 'Wine').length;
        const cocktail = filtered.filter(d => d.category === 'Cocktail').length;
        return { total, beer, wine, cocktail };
      };

      const stats = getStats();
      const filteredDrinks = getFilteredDrinks();

      // Pagination calculations - use filtered drinks
      const totalPages = Math.ceil(filteredDrinks.length / itemsPerPage);
      const startIndex = (currentPage - 1) * itemsPerPage;
      const endIndex = startIndex + itemsPerPage;
      const paginatedDrinks = filteredDrinks.slice(startIndex, endIndex);

      // Reset to last valid page when filtered drinks change
      useEffect(() => {
        const newTotalPages = Math.ceil(filteredDrinks.length / itemsPerPage);
        if (currentPage > newTotalPages && newTotalPages > 0) {
          setCurrentPage(newTotalPages);
        } else if (newTotalPages === 0) {
          setCurrentPage(1);
        }
      }, [filteredDrinks.length, itemsPerPage, dashboardCategoryFilter, dashboardSearchQuery, dashboardPresetPeriod]);

      // Show loading while checking auth
      if (authLoading) {
        return (
          <div className="min-h-screen bg-gradient-to-br from-slate-900 via-purple-900 to-slate-900 text-white flex items-center justify-center">
            <div className="text-2xl">Loading...</div>
          </div>
        );
      }

      // Show auth UI if not logged in
      if (!user) {
        return (
          <div className="min-h-screen bg-gradient-to-br from-slate-900 via-purple-900 to-slate-900 text-white flex items-center justify-center p-6">
            <div className="max-w-md w-full">
              <div className="text-center mb-8">
                <h1 className="text-4xl font-bold mb-2">Drink Log</h1>
                <p className="text-slate-300">What are you drinking?</p>
              </div>

              {!showLogin && !showSignup && (
                <div className="bg-white/10 backdrop-blur rounded-2xl p-8 space-y-4">
                  <button
                    onClick={() => {
                      setShowSignup(true);
                      setShowLogin(false);
                      setAuthError('');
                    }}
                    className="w-full bg-purple-500 hover:bg-purple-600 rounded-lg py-3 font-semibold transition-colors"
                  >
                    Sign Up
                  </button>
                  <button
                    onClick={() => {
                      setShowLogin(true);
                      setShowSignup(false);
                      setAuthError('');
                    }}
                    className="w-full bg-white/10 hover:bg-white/20 rounded-lg py-3 font-semibold transition-colors border border-white/20"
                  >
                    Sign In
                  </button>
                </div>
              )}

              {(showLogin || showSignup) && (
                <div className="bg-white/10 backdrop-blur rounded-2xl p-8">
                  <h2 className="text-2xl font-bold mb-6 text-center">
                    {showSignup ? 'Create Account' : 'Sign In'}
                  </h2>
                  
                  {authError && (
                    <div className="bg-red-500/20 border border-red-500/50 rounded-lg p-3 mb-4 text-sm">
                      {authError}
                    </div>
                  )}

                  <form onSubmit={showSignup ? handleSignUp : handleSignIn} className="space-y-4">
                    <div>
                      <input
                        type="email"
                        placeholder="Email"
                        value={email}
                        onChange={(e) => setEmail(e.target.value)}
                        required
                        className="w-full bg-white/20 rounded-lg px-4 py-3 text-white placeholder-slate-400 outline-none focus:ring-2 focus:ring-purple-400"
                      />
                    </div>
                    <div>
                      <input
                        type="password"
                        placeholder="Password"
                        value={password}
                        onChange={(e) => setPassword(e.target.value)}
                        required
                        minLength={6}
                        className="w-full bg-white/20 rounded-lg px-4 py-3 text-white placeholder-slate-400 outline-none focus:ring-2 focus:ring-purple-400"
                      />
                    </div>
                    <button
                      type="submit"
                      className="w-full bg-purple-500 hover:bg-purple-600 rounded-lg py-3 font-semibold transition-colors"
                    >
                      {showSignup ? 'Sign Up' : 'Sign In'}
                    </button>
                  </form>

                  <button
                    onClick={() => {
                      setShowLogin(false);
                      setShowSignup(false);
                      setEmail('');
                      setPassword('');
                      setAuthError('');
                    }}
                    className="w-full mt-4 text-slate-300 hover:text-white text-sm transition-colors"
                  >
                    Back
                  </button>
                </div>
              )}
            </div>
          </div>
        );
      }

      // Show loading while loading data
      if (loading) {
        return (
          <div className="min-h-screen bg-gradient-to-br from-slate-900 via-purple-900 to-slate-900 text-white flex items-center justify-center">
            <div className="text-2xl">Loading your drinks...</div>
          </div>
        );
      }

      return (
        <div className="min-h-screen bg-gradient-to-br from-slate-900 via-purple-900 to-slate-900 text-white">
          <div className="max-w-2xl mx-auto p-6 pb-24">
            <div className="flex items-center justify-between mb-8 pt-8">
              <div className="text-center flex-1">
                <h1 className="text-4xl font-bold mb-2">2026 Drink Tracker</h1>
                <p className="text-slate-300">Track every drink, understand your habits</p>
              </div>
              <div className="flex items-center gap-3">
                {/* Offline/Syncing indicators */}
                {!isOnline && (
                  <div className="flex items-center gap-2 bg-yellow-500/20 border border-yellow-500/50 rounded-lg px-3 py-1.5 text-xs">
                    <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M18.364 5.636a9 9 0 010 12.728m0 0l-2.829-2.829m2.829 2.829L21 21M15.536 8.464a5 5 0 010 7.072m0 0l-2.829-2.829m-4.243 2.829a4.978 4.978 0 01-1.414-2.83m-1.414 5.658a9 9 0 01-2.167-9.238m7.824 2.167a1 1 0 111.414 1.414m-1.414-1.414L3 3m8.293 8.293l1.414 1.414" />
                    </svg>
                    <span className="hidden sm:inline">Offline</span>
                  </div>
                )}
                {isSyncing && (
                  <div className="flex items-center gap-2 bg-blue-500/20 border border-blue-500/50 rounded-lg px-3 py-1.5 text-xs">
                    <svg className="w-4 h-4 animate-spin" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                    </svg>
                    <span className="hidden sm:inline">Syncing...</span>
                  </div>
                )}
                {cacheTimestamp && isOnline && !isSyncing && (
                  <div className="text-xs text-slate-400 hidden lg:inline" title={`Last synced: ${new Date(cacheTimestamp).toLocaleTimeString()}`}>
                    {Math.floor((Date.now() - cacheTimestamp) / 1000 / 60) < 1 ? 'Just now' : `${Math.floor((Date.now() - cacheTimestamp) / 1000 / 60)}m ago`}
                  </div>
                )}
                <span className="text-sm text-slate-300 hidden sm:inline">{user.email}</span>
                <button
                  onClick={handleSignOut}
                  className="bg-white/10 hover:bg-white/20 rounded-lg px-4 py-2 text-sm font-semibold transition-colors flex items-center gap-2"
                >
                  <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M17 16l4-4m0 0l-4-4m4 4H7m6 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h4a3 3 0 013 3v1" />
                  </svg>
                  Sign Out
                </button>
              </div>
            </div>

            {suggestion && !editMode && (
              <div className="bg-green-500/20 border border-green-500/50 backdrop-blur rounded-xl p-4 mb-6 flex items-center justify-between">
                <div className="flex-1">
                  <div className="font-semibold">Add to Quick Log?</div>
                  <div className="text-sm text-slate-300">
                    You've logged "{suggestion.name}" {suggestion.count} times
                  </div>
                </div>
                <div className="flex gap-2">
                  <button
                    onClick={() => addToQuickLog(suggestion.name, suggestion.category)}
                    className="bg-green-500 hover:bg-green-600 px-4 py-2 rounded-lg font-semibold transition-colors"
                  >
                    Add
                  </button>
                  <button
                    onClick={() => dismissSuggestion(suggestion.name)}
                    className="bg-white/20 hover:bg-white/30 px-4 py-2 rounded-lg transition-colors"
                  >
                    Dismiss
                  </button>
                </div>
              </div>
            )}

            {/* Enhanced Dashboard */}
            <div className="bg-white/10 backdrop-blur rounded-2xl p-6 mb-6">
              {/* Filters and Period Selector */}
              <div className="mb-6 space-y-4">
                {/* Preset Period Buttons */}
                <div className="flex flex-wrap gap-2">
                  {['thisWeek', 'thisMonth', 'last30Days', 'thisYear', 'all'].map(period => {
                    const labels = {
                      thisWeek: 'This Week',
                      thisMonth: 'This Month',
                      last30Days: 'Last 30 Days',
                      thisYear: 'This Year',
                      all: 'All Time'
                    };
                    return (
                      <button
                        key={period}
                        onClick={() => setDashboardPresetPeriod(period)}
                        className={`px-4 py-2 rounded-lg font-semibold text-sm transition-colors ${
                          dashboardPresetPeriod === period
                            ? 'bg-purple-500 text-white'
                            : 'bg-white/10 hover:bg-white/20 text-slate-300'
                        }`}
                      >
                        {labels[period]}
                      </button>
                    );
                  })}
                </div>

                {/* Category Filter and Search */}
                <div className="flex gap-3">
                  <select
                    value={dashboardCategoryFilter}
                    onChange={(e) => setDashboardCategoryFilter(e.target.value)}
                    className="flex-1 bg-white/10 border border-white/20 rounded-lg px-4 py-2 text-white focus:outline-none focus:ring-2 focus:ring-purple-400"
                  >
                    <option value="all">All Categories</option>
                    <option value="Beer">Beer</option>
                    <option value="Wine">Wine</option>
                    <option value="Cocktail">Cocktail</option>
                  </select>
                  <input
                    type="text"
                    placeholder="Search drinks..."
                    value={dashboardSearchQuery}
                    onChange={(e) => setDashboardSearchQuery(e.target.value)}
                    className="flex-1 bg-white/10 border border-white/20 rounded-lg px-4 py-2 text-white placeholder-slate-400 focus:outline-none focus:ring-2 focus:ring-purple-400"
                  />
                </div>
              </div>

              {/* Main Stats Card */}
              {(() => {
                const filtered = getFilteredDrinks();
                const dailyAvg = calculateDailyAverage(filtered, dashboardPresetPeriod);
                const streak = calculateStreak(filtered);
                const peakDays = calculatePeakDays(filtered);
                const weeklyStats = calculateWeeklyStats(filtered);
                const monthlyStats = calculateMonthlyStats(filtered);
                const yearlyStats = calculateYearlyStats(filtered);

                return (
                  <>
                    {/* Total and Category Breakdown */}
                    <div className="flex items-center justify-between mb-6">
                      <div>
                        <div className="text-slate-300 text-sm mb-1">Total Drinks</div>
                        <div className="text-5xl font-bold">{stats.total}</div>
                      </div>
                      <svg className="w-12 h-12 text-purple-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 7h8m0 0v8m0-8l-8 8-4-4-6 6" />
                      </svg>
                    </div>

                    <div className="grid grid-cols-3 gap-4 mb-6 pb-6 border-b border-white/20">
                      <div className="text-center">
                        <div className="text-2xl font-bold text-amber-400">{stats.beer}</div>
                        <div className="text-xs text-slate-300 mt-1">Beer</div>
                      </div>
                      <div className="text-center">
                        <div className="text-2xl font-bold text-pink-400">{stats.cocktail}</div>
                        <div className="text-xs text-slate-300 mt-1">Cocktail</div>
                      </div>
                      <div className="text-center">
                        <div className="text-2xl font-bold text-red-400">{stats.wine}</div>
                        <div className="text-xs text-slate-300 mt-1">Wine</div>
                      </div>
                    </div>

                    {/* Metrics Grid */}
                    <div className="grid grid-cols-2 gap-4 mb-6">
                      <div className="bg-white/5 rounded-xl p-4">
                        <div className="text-slate-400 text-xs mb-1">Daily Average</div>
                        <div className="text-2xl font-bold">{dailyAvg}</div>
                        <div className="text-xs text-slate-500 mt-1">drinks per day</div>
                      </div>
                      <div className="bg-white/5 rounded-xl p-4">
                        <div className="text-slate-400 text-xs mb-1">Current Streak</div>
                        <div className="text-2xl font-bold">{streak.currentStreak}</div>
                        <div className="text-xs text-slate-500 mt-1">consecutive days</div>
                      </div>
                      <div className="bg-white/5 rounded-xl p-4">
                        <div className="text-slate-400 text-xs mb-1">Longest Streak</div>
                        <div className="text-2xl font-bold">{streak.longestStreak}</div>
                        <div className="text-xs text-slate-500 mt-1">consecutive days</div>
                      </div>
                      <div className="bg-white/5 rounded-xl p-4">
                        <div className="text-slate-400 text-xs mb-1">Peak Day</div>
                        <div className="text-2xl font-bold">{peakDays.dayOfWeek.peak}</div>
                        <div className="text-xs text-slate-500 mt-1">{peakDays.dayOfWeek.count} drinks</div>
                      </div>
                    </div>

                    {/* Time Series Display */}
                    {dashboardPeriod === 'week' && weeklyStats.length > 0 && (
                      <div className="mb-6">
                        <h3 className="text-lg font-semibold text-slate-300 mb-3">Weekly Breakdown</h3>
                        <div className="space-y-2">
                          {weeklyStats.slice(0, 8).map(week => {
                            const counts = weeklyStats.map(w => w.count);
                            const maxCount = counts.length > 0 ? Math.max(...counts) : 0;
                            const percentage = maxCount > 0 ? (week.count / maxCount) * 100 : 0;
                            return (
                              <div key={week.week} className="flex items-center gap-3">
                                <div className="text-xs text-slate-400 w-20">
                                  {week.startDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric' })}
                                </div>
                                <div className="flex-1 bg-white/10 rounded-full h-6 relative overflow-hidden">
                                  <div
                                    className="bg-purple-500 h-full rounded-full transition-all"
                                    style={{ width: `${percentage}%` }}
                                  />
                                  <div className="absolute inset-0 flex items-center justify-center text-xs font-semibold">
                                    {week.count}
                                  </div>
                                </div>
                              </div>
                            );
                          })}
                        </div>
                      </div>
                    )}

                    {dashboardPeriod === 'month' && monthlyStats.length > 0 && (
                      <div className="mb-6">
                        <h3 className="text-lg font-semibold text-slate-300 mb-3">Monthly Breakdown</h3>
                        <div className="space-y-2">
                          {monthlyStats.slice(0, 12).map(month => {
                            const counts = monthlyStats.map(m => m.count);
                            const maxCount = counts.length > 0 ? Math.max(...counts) : 0;
                            const percentage = maxCount > 0 ? (month.count / maxCount) * 100 : 0;
                            return (
                              <div key={month.month} className="flex items-center gap-3">
                                <div className="text-xs text-slate-400 w-32">{month.monthName}</div>
                                <div className="flex-1 bg-white/10 rounded-full h-6 relative overflow-hidden">
                                  <div
                                    className="bg-purple-500 h-full rounded-full transition-all"
                                    style={{ width: `${percentage}%` }}
                                  />
                                  <div className="absolute inset-0 flex items-center justify-center text-xs font-semibold">
                                    {month.count}
                                  </div>
                                </div>
                              </div>
                            );
                          })}
                        </div>
                      </div>
                    )}

                    {dashboardPeriod === 'year' && yearlyStats.length > 0 && (
                      <div className="mb-6">
                        <h3 className="text-lg font-semibold text-slate-300 mb-3">Yearly Breakdown</h3>
                        <div className="space-y-2">
                          {yearlyStats.map(year => {
                            const counts = yearlyStats.map(y => y.count);
                            const maxCount = counts.length > 0 ? Math.max(...counts) : 0;
                            const percentage = maxCount > 0 ? (year.count / maxCount) * 100 : 0;
                            return (
                              <div key={year.year} className="flex items-center gap-3">
                                <div className="text-xs text-slate-400 w-20">{year.year}</div>
                                <div className="flex-1 bg-white/10 rounded-full h-6 relative overflow-hidden">
                                  <div
                                    className="bg-purple-500 h-full rounded-full transition-all"
                                    style={{ width: `${percentage}%` }}
                                  />
                                  <div className="absolute inset-0 flex items-center justify-center text-xs font-semibold">
                                    {year.count}
                                  </div>
                                </div>
                              </div>
                            );
                          })}
                        </div>
                      </div>
                    )}

                    {/* Period Selector Tabs */}
                    <div className="flex gap-2 border-t border-white/20 pt-4">
                      {['week', 'month', 'year'].map(period => (
                        <button
                          key={period}
                          onClick={() => setDashboardPeriod(period)}
                          className={`px-4 py-2 rounded-lg font-semibold text-sm transition-colors capitalize ${
                            dashboardPeriod === period
                              ? 'bg-purple-500 text-white'
                              : 'bg-white/10 hover:bg-white/20 text-slate-300'
                          }`}
                        >
                          {period}
                        </button>
                      ))}
                    </div>
                  </>
                );
              })()}
            </div>

            <div className="mb-6">
              <div className="flex items-center justify-between mb-3">
                <h2 className="text-lg font-semibold text-slate-300">Quick Log</h2>
                <button
                  onClick={() => {
                    setEditMode(!editMode);
                    setEditingDrink(null);
                    setEditName('');
                    setEditCategory('');
                  }}
                  className="text-sm text-purple-400 hover:text-purple-300 flex items-center gap-1"
                >
                  <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" />
                  </svg>
                  {editMode ? 'Done' : 'Edit'}
                </button>
              </div>

              {editingDrink && (
                <div className="bg-white/10 backdrop-blur rounded-xl p-4 mb-3">
                  <div className="text-sm font-semibold mb-3">
                    {editingDrink === '__NEW__' ? 'Create New Quick Log Button' : 'Edit Drink'}
                  </div>
                  <input
                    type="text"
                    value={editName}
                    onChange={(e) => setEditName(e.target.value)}
                    className="w-full bg-white/20 rounded-lg px-4 py-3 mb-3 text-white placeholder-slate-400 outline-none focus:ring-2 focus:ring-purple-400"
                    placeholder="Drink name"
                    autoFocus
                  />
                  <div className="text-sm text-slate-300 mb-2">Category:</div>
                  <div className="flex gap-2 mb-3">
                    <button
                      onClick={() => setEditCategory('Beer')}
                      className={`flex-1 border rounded-lg py-2 font-semibold transition-colors ${
                        editCategory === 'Beer' 
                          ? 'bg-amber-500 border-amber-500' 
                          : 'bg-amber-500/20 border-amber-500/50 hover:bg-amber-500/40'
                      }`}
                    >
                      Beer
                    </button>
                    <button
                      onClick={() => setEditCategory('Cocktail')}
                      className={`flex-1 border rounded-lg py-2 font-semibold transition-colors ${
                        editCategory === 'Cocktail' 
                          ? 'bg-pink-500 border-pink-500' 
                          : 'bg-pink-500/20 border-pink-500/50 hover:bg-pink-500/40'
                      }`}
                    >
                      Cocktail
                    </button>
                    <button
                      onClick={() => setEditCategory('Wine')}
                      className={`flex-1 border rounded-lg py-2 font-semibold transition-colors ${
                        editCategory === 'Wine' 
                          ? 'bg-red-500 border-red-500' 
                          : 'bg-red-500/20 border-red-500/50 hover:bg-red-500/40'
                      }`}
                    >
                      Wine
                    </button>
                  </div>
                  <div className="flex gap-2">
                    <button
                      onClick={() => {
                        if (editingDrink === '__NEW__') {
                          createNewQuickLogDrink();
                        } else {
                          updateQuickLogDrink(editingDrink, editName, editCategory);
                        }
                      }}
                      className="flex-1 bg-purple-500 hover:bg-purple-600 rounded-lg py-2 font-semibold transition-colors"
                    >
                      {editingDrink === '__NEW__' ? 'Create' : 'Save'}
                    </button>
                    <button
                      onClick={() => {
                        setEditingDrink(null);
                        setEditName('');
                        setEditCategory('');
                      }}
                      className="px-6 bg-white/20 hover:bg-white/30 rounded-lg transition-colors"
                    >
                      Cancel
                    </button>
                  </div>
                </div>
              )}

              <div className="grid grid-cols-2 gap-3 mb-3">
                {quickLogDrinks.map((drink) => (
                  <div key={drink.name} className="relative">
                    <button
                      onClick={() => {
                        if (editMode) {
                          startEditingDrink(drink);
                        } else {
                          quickAddDrink(drink.name, drink.category);
                        }
                      }}
                      className={`w-full bg-white/10 backdrop-blur rounded-xl py-3 font-semibold transition-all ${
                        editMode ? 'hover:bg-white/20 ring-2 ring-purple-400/50' : 'hover:bg-purple-500 hover:scale-105 active:scale-95'
                      }`}
                    >
                      <div>{drink.name}</div>
                      <div className="text-xs text-slate-300 mt-1">{drink.category}</div>
                    </button>
                    {editMode && (
                      <button
                        onClick={() => removeFromQuickLog(drink.name)}
                        className="absolute -top-2 -right-2 bg-red-500 hover:bg-red-600 rounded-full p-1 shadow-lg"
                      >
                        <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                        </svg>
                      </button>
                    )}
                  </div>
                ))}
                
                {/* Add New Button - only shown in edit mode */}
                {editMode && !editingDrink && (
                  <button
                    onClick={startCreatingNewDrink}
                    className="w-full bg-white/10 backdrop-blur rounded-xl py-3 font-semibold transition-all hover:bg-white/20 ring-2 ring-dashed ring-purple-400/50 border-2 border-dashed border-purple-400/30 flex items-center justify-center gap-2"
                  >
                    <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" />
                    </svg>
                    <span>Add New</span>
                  </button>
                )}
              </div>
              
              {!editMode && (
                !showOtherForm ? (
                  <button
                    onClick={() => setShowOtherForm(true)}
                    className="w-full bg-white/10 backdrop-blur hover:bg-white/20 rounded-xl py-3 font-semibold transition-colors flex items-center justify-center gap-2"
                  >
                    <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" />
                    </svg>
                    Other
                  </button>
                ) : (
                  <div className="bg-white/10 backdrop-blur rounded-xl p-4">
                    <input
                      type="text"
                      placeholder="What did you drink?"
                      value={customDrink}
                      onChange={(e) => setCustomDrink(e.target.value)}
                      className="w-full bg-white/20 rounded-lg px-4 py-3 mb-3 text-white placeholder-slate-400 outline-none focus:ring-2 focus:ring-purple-400"
                      autoFocus
                    />
                    <div className="text-sm text-slate-300 mb-2">Select category:</div>
                    <div className="flex gap-2 mb-3">
                      <button
                        onClick={() => addCustomDrink('Beer')}
                        className="flex-1 bg-amber-500/20 hover:bg-amber-500 border border-amber-500/50 rounded-lg py-2 font-semibold transition-colors"
                      >
                        Beer
                      </button>
                      <button
                        onClick={() => addCustomDrink('Cocktail')}
                        className="flex-1 bg-pink-500/20 hover:bg-pink-500 border border-pink-500/50 rounded-lg py-2 font-semibold transition-colors"
                      >
                        Cocktail
                      </button>
                      <button
                        onClick={() => addCustomDrink('Wine')}
                        className="flex-1 bg-red-500/20 hover:bg-red-500 border border-red-500/50 rounded-lg py-2 font-semibold transition-colors"
                      >
                        Wine
                      </button>
                    </div>
                    <button
                      onClick={() => {
                        setShowOtherForm(false);
                        setCustomDrink('');
                      }}
                      className="w-full bg-white/20 hover:bg-white/30 rounded-lg py-2 transition-colors"
                    >
                      Cancel
                    </button>
                  </div>
                )
              )}
            </div>

            <div className="space-y-3">
              <div className="flex items-center justify-between mb-3">
                <div className="flex items-center gap-3">
                  <h2 className="text-lg font-semibold text-slate-300">History</h2>
                  {drinks.length > 0 && (
                    <span className="text-xs text-slate-400 bg-white/10 px-2 py-1 rounded">
                      {filteredDrinks.length === drinks.length 
                        ? `${filteredDrinks.length} ${filteredDrinks.length === 1 ? 'drink' : 'drinks'}`
                        : `${filteredDrinks.length} of ${drinks.length} ${drinks.length === 1 ? 'drink' : 'drinks'}`
                      }
                    </span>
                  )}
                </div>
                {drinks.length > 0 && (
                  <div className="flex items-center gap-2">
                    <button
                      onClick={() => setShowBulkDelete(true)}
                      className="text-sm text-red-400 hover:text-red-300 flex items-center gap-1 bg-white/10 hover:bg-white/20 px-3 py-1.5 rounded-lg transition-colors"
                    >
                      <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                      </svg>
                      Bulk Delete
                    </button>
                    <button
                      onClick={exportToCSV}
                      className="text-sm text-purple-400 hover:text-purple-300 flex items-center gap-1 bg-white/10 hover:bg-white/20 px-3 py-1.5 rounded-lg transition-colors"
                    >
                      Export CSV
                    </button>
                  </div>
                )}
              </div>
              {drinks.length === 0 ? (
                <div className="text-center py-12 text-slate-400">
                  <svg className="w-16 h-16 mx-auto mb-4 opacity-50" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z" />
                  </svg>
                  <p>No drinks logged yet</p>
                  <p className="text-sm mt-2">Tap a button above to start tracking</p>
                </div>
              ) : filteredDrinks.length === 0 ? (
                <div className="text-center py-12 text-slate-400">
                  <svg className="w-16 h-16 mx-auto mb-4 opacity-50" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
                  </svg>
                  <p>No drinks match your filters</p>
                  <p className="text-sm mt-2">Try adjusting your search or filter settings</p>
                </div>
              ) : (
                <>
                  {paginatedDrinks.map((drink) => (
                    <div
                      key={drink.id}
                      className="bg-white/10 backdrop-blur rounded-xl p-4 flex items-center justify-between hover:bg-white/15 transition-colors"
                    >
                      <div>
                        <div className="font-semibold text-lg">{drink.name}</div>
                        <div className="text-slate-300 text-sm">
                          {drink.category}  {formatDate(drink.timestamp)} at {formatTime(drink.timestamp)}
                        </div>
                      </div>
                      <button
                        onClick={() => deleteDrink(drink.id)}
                        className="text-red-400 hover:text-red-300 text-sm px-3 py-1 rounded-lg hover:bg-white/10 transition-colors"
                      >
                        Delete
                      </button>
                    </div>
                  ))}
                  
                  {/* Pagination Controls */}
                  {totalPages > 1 && (
                    <div className="flex items-center justify-center gap-2 mt-6 pt-6 border-t border-white/20">
                      <button
                        onClick={() => setCurrentPage(prev => Math.max(1, prev - 1))}
                        disabled={currentPage === 1}
                        className={`px-4 py-2 rounded-lg font-semibold transition-colors flex items-center gap-1 ${
                          currentPage === 1
                            ? 'bg-white/5 text-slate-500 cursor-not-allowed'
                            : 'bg-white/10 hover:bg-white/20 text-white'
                        }`}
                      >
                        <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 19l-7-7 7-7" />
                        </svg>
                        Previous
                      </button>
                      
                      <div className="flex items-center gap-1">
                        {Array.from({ length: totalPages }, (_, i) => i + 1).map((page) => {
                          // Show first page, last page, current page, and pages around current
                          if (
                            page === 1 ||
                            page === totalPages ||
                            (page >= currentPage - 1 && page <= currentPage + 1)
                          ) {
                            return (
                              <button
                                key={page}
                                onClick={() => setCurrentPage(page)}
                                className={`min-w-[2.5rem] px-3 py-2 rounded-lg font-semibold transition-colors ${
                                  currentPage === page
                                    ? 'bg-purple-500 text-white'
                                    : 'bg-white/10 hover:bg-white/20 text-white'
                                }`}
                              >
                                {page}
                              </button>
                            );
                          } else if (
                            page === currentPage - 2 ||
                            page === currentPage + 2
                          ) {
                            return (
                              <span key={page} className="px-2 text-slate-400">
                                ...
                              </span>
                            );
                          }
                          return null;
                        })}
                      </div>
                      
                      <button
                        onClick={() => setCurrentPage(prev => Math.min(totalPages, prev + 1))}
                        disabled={currentPage === totalPages}
                        className={`px-4 py-2 rounded-lg font-semibold transition-colors flex items-center gap-1 ${
                          currentPage === totalPages
                            ? 'bg-white/5 text-slate-500 cursor-not-allowed'
                            : 'bg-white/10 hover:bg-white/20 text-white'
                        }`}
                      >
                        Next
                        <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" />
                        </svg>
                      </button>
                    </div>
                  )}
                  
                  {/* Page info */}
                  {totalPages > 1 && (
                    <div className="text-center text-sm text-slate-400 mt-2">
                      Showing {startIndex + 1}-{Math.min(endIndex, filteredDrinks.length)} of {filteredDrinks.length} drinks
                    </div>
                  )}
                </>
              )}
            </div>

            {/* Bulk Delete Modal */}
            {showBulkDelete && (
              <div className="fixed inset-0 bg-black/50 backdrop-blur-sm flex items-center justify-center z-50 p-4">
                <div className="bg-slate-800 rounded-2xl p-6 max-w-md w-full max-h-[90vh] overflow-y-auto">
                  <div className="flex items-center justify-between mb-4">
                    <h3 className="text-xl font-semibold text-white">Bulk Delete Drinks</h3>
                    <button
                      onClick={() => {
                        setShowBulkDelete(false);
                        setDeleteStartDate('');
                        setDeleteEndDate('');
                      }}
                      className="text-slate-400 hover:text-white transition-colors"
                      disabled={deleting}
                    >
                      <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                      </svg>
                    </button>
                  </div>

                  <div className="space-y-4">
                    {/* Delete All Option */}
                    <div className="bg-red-500/10 border border-red-500/30 rounded-lg p-4">
                      <div className="text-red-400 font-semibold mb-2">Delete All Drinks</div>
                      <div className="text-sm text-slate-300 mb-3">
                        This will permanently delete all {drinks.length} drink{drinks.length === 1 ? '' : 's'} in your account. This action cannot be undone.
                      </div>
                      <button
                        onClick={deleteAllDrinks}
                        disabled={deleting || drinks.length === 0}
                        className="w-full bg-red-500 hover:bg-red-600 disabled:bg-red-500/50 disabled:cursor-not-allowed rounded-lg py-2 font-semibold transition-colors flex items-center justify-center gap-2"
                      >
                        {deleting ? (
                          <>
                            <svg className="animate-spin h-4 w-4" fill="none" viewBox="0 0 24 24">
                              <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                              <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                            </svg>
                            Deleting...
                          </>
                        ) : (
                          'Delete All'
                        )}
                      </button>
                    </div>

                    <div className="relative">
                      <div className="absolute inset-0 flex items-center">
                        <div className="w-full border-t border-white/20"></div>
                      </div>
                      <div className="relative flex justify-center text-sm">
                        <span className="px-2 bg-slate-800 text-slate-400">OR</span>
                      </div>
                    </div>

                    <div>
                      <label className="block text-sm text-slate-300 mb-2">Start Date</label>
                      <input
                        type="date"
                        value={deleteStartDate}
                        onChange={(e) => setDeleteStartDate(e.target.value)}
                        className="w-full bg-white/10 border border-white/20 rounded-lg px-4 py-2 text-white focus:outline-none focus:ring-2 focus:ring-purple-400"
                        disabled={deleting}
                      />
                    </div>

                    <div>
                      <label className="block text-sm text-slate-300 mb-2">End Date</label>
                      <input
                        type="date"
                        value={deleteEndDate}
                        onChange={(e) => setDeleteEndDate(e.target.value)}
                        className="w-full bg-white/10 border border-white/20 rounded-lg px-4 py-2 text-white focus:outline-none focus:ring-2 focus:ring-purple-400"
                        disabled={deleting}
                      />
                    </div>

                    {/* Preview */}
                    {deleteStartDate && deleteEndDate && (
                      <div className="bg-red-500/10 border border-red-500/30 rounded-lg p-4">
                        <div className="text-red-400 font-semibold mb-2">
                          {(() => {
                            const { count } = getDrinksInDateRange(deleteStartDate, deleteEndDate);
                            return count > 0 
                              ? `${count} drink${count === 1 ? '' : 's'} will be deleted`
                              : 'No drinks found in this date range';
                          })()}
                        </div>
                        {(() => {
                          const { count, drinks: previewDrinks } = getDrinksInDateRange(deleteStartDate, deleteEndDate);
                          if (count > 0 && count <= 5) {
                            return (
                              <div className="text-sm text-slate-300 space-y-1">
                                {previewDrinks.slice(0, 5).map(drink => (
                                  <div key={drink.id}>
                                    {drink.name}  {formatDate(drink.timestamp)}
                                  </div>
                                ))}
                              </div>
                            );
                          } else if (count > 5) {
                            return (
                              <div className="text-sm text-slate-300">
                                Showing first 5 of {count} drinks...
                              </div>
                            );
                          }
                          return null;
                        })()}
                      </div>
                    )}

                    <div className="flex gap-3 pt-2">
                      <button
                        onClick={() => {
                          setShowBulkDelete(false);
                          setDeleteStartDate('');
                          setDeleteEndDate('');
                        }}
                        className="flex-1 bg-white/10 hover:bg-white/20 rounded-lg py-2 font-semibold transition-colors"
                        disabled={deleting}
                      >
                        Cancel
                      </button>
                      <button
                        onClick={() => deleteDrinksByDateRange(deleteStartDate, deleteEndDate)}
                        disabled={deleting || !deleteStartDate || !deleteEndDate || getDrinksInDateRange(deleteStartDate, deleteEndDate).count === 0}
                        className="flex-1 bg-red-500 hover:bg-red-600 disabled:bg-red-500/50 disabled:cursor-not-allowed rounded-lg py-2 font-semibold transition-colors flex items-center justify-center gap-2"
                      >
                        {deleting ? (
                          <>
                            <svg className="animate-spin h-4 w-4" fill="none" viewBox="0 0 24 24">
                              <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                              <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                            </svg>
                            Deleting...
                          </>
                        ) : (
                          'Delete'
                        )}
                      </button>
                    </div>
                  </div>
                </div>
              </div>
            )}
          </div>
        </div>
      );
    }

    ReactDOM.render(<DrinkTracker />, document.getElementById('root'));
  </script>
</body>
</html>
